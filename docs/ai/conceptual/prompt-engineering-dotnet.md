---
title: Prompt engineering concepts
description: Learn basic prompt engineering concepts and how to implement them using .NET tools such as Microsoft Agent Framework.
ms.topic: concept-article
ms.date: 02/05/2026
---

# Prompt engineering in .NET

In this article, you explore essential prompt engineering concepts. Many AI models are prompt-based, meaning they respond to user input text (a *prompt*) with a response generated by predictive algorithms (a *completion*). Newer models also often support completions in chat form, with messages based on roles (system, user, assistant) and chat history to preserve conversations.

## Work with prompts

Models that support chat-based apps use three roles to organize completions: a *system* role that controls the chat, a *user* role to represent user input, and an *assistant* role for responding to users. Divide your prompts into messages for each role:

- [*System messages*](/azure/ai-services/openai/concepts/advanced-prompt-engineering?pivots=programming-language-chat-completions#system-message) give the model instructions about the assistant. A prompt can have only one system message, and it must be the first message.
- *User messages* include prompts from the user, examples, or instructions for the assistant. An example chat completion must have at least one user message.
- *Assistant messages* show example or historical completions and must contain a response to the preceding user message. Assistant messages aren't required, but if you include one, it must be paired with a user message to form an example.

## Use instructions to improve the completion

An *instruction* is text that tells the model how to respond. An instruction can be a *directive* or an *imperative*:

- *Directives* tell the model how to behave but aren't simple commands&mdash;think character setup for an improv actor: **"You're helping students learn about U.S. history, so talk about the U.S. unless they specifically ask about other countries."**
- *Imperatives* are unambiguous commands for the model to follow. **"Translate to Tagalog:"**

## Use examples to guide the model

An example is text that shows the model how to respond by providing sample user input and model output. The model uses examples to infer what to include in completions. Examples can come either before or after the instructions in an engineered prompt, but the two shouldn't be interspersed.

An example starts with a prompt and can optionally include a completion. A completion in an example doesn't have to include the verbatim response&mdash;it might just contain a formatted word, the first bullet in an unordered list, or something similar to indicate how each completion should start.

Examples are classified as [zero-shot learning](zero-shot-learning.md#zero-shot-learning) or [few-shot learning](zero-shot-learning.md#few-shot-learning) based on whether they contain verbatim completions.

- **Zero-shot learning** examples include a prompt with no verbatim completion. This approach tests a model's responses without giving it example data output. Zero-shot prompts can have completions that include cues, such as indicating the model should output an ordered list by including **"1."** as the completion.
- **Few-shot learning** examples include several pairs of prompts with verbatim completions. Few-shot learning can change the model's behavior by adding to its existing knowledge.

## Cues

A *cue* is text that conveys the desired structure or format of output. Like an instruction, a cue isn't processed by the model as if it were user input. Like an example, a cue shows the model what you want instead of telling it what to do. You can add as many cues as you want, so you can iterate to get the result you want. Cues are used with an instruction or an example and should be at the end of the prompt.

## Example prompt using .NET

.NET provides various tools to prompt and chat with different AI models. You can use [Agent Framework](/agent-framework/) to connect to a wide variety of AI models and services. Agent Framework includes tools to create agents with system instructions and maintain conversation state across multiple turns.

Consider the following code example:

:::code language="csharp" source="../snippets/prompt-engineering/multi-turn-chat.cs":::

The preceding code:

- Creates an Azure OpenAI client with an endpoint and API key.
- Gets a chat client for the GPT-4o model and converts it to an AI agent.
- Creates an agent session to maintain conversation state across multiple turns.
- Accepts user input in a loop to allow for different types of prompts.
- Asynchronously streams the AI response and displays it to the console.

## Related content

- [Prompt engineering techniques](/azure/ai-foundry/openai/concepts/prompt-engineering)
- [System message design](/azure/ai-services/openai/concepts/advanced-prompt-engineering)
