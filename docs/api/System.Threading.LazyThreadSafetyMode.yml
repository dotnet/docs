items:
- uid: System.Threading.LazyThreadSafetyMode
  id: LazyThreadSafetyMode
  parent: System.Threading
  children:
  - System.Threading.LazyThreadSafetyMode.ExecutionAndPublication
  - System.Threading.LazyThreadSafetyMode.None
  - System.Threading.LazyThreadSafetyMode.PublicationOnly
  href: System.Threading.LazyThreadSafetyMode.yml
  name: LazyThreadSafetyMode
  fullName: System.Threading.LazyThreadSafetyMode
  type: Enum
  source:
    remote: &o0
      path: src/mscorlib/src/System/Threading/LazyInitializer.cs
      branch: master
      repo: https://github.com/chenkennt/coreclr.git
    path: src/mscorlib/src/System/Threading/LazyInitializer.cs
    startLine: 20
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Specifies how a @'System.Lazy`1' instance synchronizes access among multiple threads.
  syntax:
    content: public enum LazyThreadSafetyMode
    content.vb: Public Enum LazyThreadSafetyMode
- uid: System.Threading.LazyThreadSafetyMode.None
  id: None
  parent: System.Threading.LazyThreadSafetyMode
  href: System.Threading.LazyThreadSafetyMode.yml
  name: None
  fullName: System.Threading.LazyThreadSafetyMode.None
  type: Field
  source:
    remote: *o0
    path: src/mscorlib/src/System/Threading/LazyInitializer.cs
    startLine: 28
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: The @'System.Lazy`1' instance is not thread safe; if the instance is accessed from multiple threads, its behavior is undefined. Use this mode only when high performance is crucial and the @'System.Lazy`1' instance is guaranteed never to be initialized from more than one thread. If you use a @'System.Lazy`1' constructor that specifies an initialization method (*valueFactory* parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the @'System.Lazy`1.Value' property, then the exception is cached and thrown again on subsequent calls to the @'System.Lazy`1.Value' property. If you use a @'System.Lazy`1' constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for *T* are not cached. In that case, a subsequent call to the @'System.Lazy`1.Value' property might successfully initialize the @'System.Lazy`1' instance. If the initialization method recursively accesses the @'System.Lazy`1.Value' property of the @'System.Lazy`1' instance, an @'System.InvalidOperationException' is thrown.
  syntax:
    content: None = 0
- uid: System.Threading.LazyThreadSafetyMode.PublicationOnly
  id: PublicationOnly
  parent: System.Threading.LazyThreadSafetyMode
  href: System.Threading.LazyThreadSafetyMode.yml
  name: PublicationOnly
  fullName: System.Threading.LazyThreadSafetyMode.PublicationOnly
  type: Field
  source:
    remote: *o0
    path: src/mscorlib/src/System/Threading/LazyInitializer.cs
    startLine: 38
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: When multiple threads try to initialize a @'System.Lazy`1' instance simultaneously, all threads are allowed to run the initialization method (or the default constructor, if there is no initialization method). The first thread to complete initialization sets the value of the @'System.Lazy`1' instance. That value is returned to any other threads that were simultaneously running the initialization method, unless the initialization method throws exceptions on those threads. Any instances of *T* that were created by the competing threads are discarded. If the initialization method throws an exception on any thread, the exception is propagated out of the @'System.Lazy`1.Value' property on that thread. The exception is not cached. The value of the @'System.Lazy`1.IsValueCreated' property remains false, and subsequent calls to the @'System.Lazy`1.Value' property, either by the thread where the exception was thrown or by other threads, cause the initialization method to run again. If the initialization method recursively accesses the @'System.Lazy`1.Value' property of the @'System.Lazy`1' instance, no exception is thrown.
  syntax:
    content: PublicationOnly = 1
- uid: System.Threading.LazyThreadSafetyMode.ExecutionAndPublication
  id: ExecutionAndPublication
  parent: System.Threading.LazyThreadSafetyMode
  href: System.Threading.LazyThreadSafetyMode.yml
  name: ExecutionAndPublication
  fullName: System.Threading.LazyThreadSafetyMode.ExecutionAndPublication
  type: Field
  source:
    remote: *o0
    path: src/mscorlib/src/System/Threading/LazyInitializer.cs
    startLine: 46
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: Locks are used to ensure that only a single thread can initialize a @'System.Lazy`1' instance in a thread-safe manner. If the initialization method (or the default constructor, if there is no initialization method) uses locks internally, deadlocks can occur. If you use a @'System.Lazy`1' constructor that specifies an initialization method (*valueFactory* parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the @'System.Lazy`1.Value' property, then the exception is cached and thrown again on subsequent calls to the @'System.Lazy`1.Value' property. If you use a @'System.Lazy`1' constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for *T* are not cached. In that case, a subsequent call to the @'System.Lazy`1.Value' property might successfully initialize the @'System.Lazy`1' instance. If the initialization method recursively accesses the @'System.Lazy`1.Value' property of the @'System.Lazy`1' instance, an @'System.InvalidOperationException' is thrown.
  syntax:
    content: ExecutionAndPublication = 2
references:
- uid: System.Threading.Lazy{T}
- uid: System.Threading
  isExternal: false
  name: System.Threading
  fullName: System.Threading
- uid: System.InvalidOperationException
