---
title: Compile-time options validation source generation
author: tarekgh
description: Learn how to utilize compile-time source generation for validating options.
ms.author: tarekms
ms.date: 10/23/2023
---

# Compile-time options validation source generation

In the [options pattern](options.md), various methods for validating options are presented. These methods include using data annotation attributes or employing a custom validator. Data annotation attributes are validated at runtime and can incur performance costs. This article demonstrates how to utilize the options validation source generator to produce optimized validation code during compile time.

## Automatic IValidateOptions implementation generation

In the [options pattern](options.md), we've illustrated how to implement the IValidateOptions interface for validating options. The options validation source generator can automatically create the IValidateOptions interface implementation by leveraging data annotation attributes on the options class.

Let's take previous annotation attributes example which mentioned in [options pattern](options.md) to convert it to use the options validation source generator.

Consider the following *appsettings.json* file:

```json
{
  "MyCustomSettingsSection": {
    "SiteTitle": "Amazing docs from Awesome people!",
    "Scale": 10,
    "VerbosityLevel": 32
  }
}
```

The following class binds to the `"MyCustomSettingsSection"` configuration section and applies a couple of `DataAnnotations` rules:

:::code language="csharp" source="snippets/configuration/console-json/SettingsOptions.cs":::

In the preceding `SettingsOptions` class, the `ConfigurationSectionName` property contains the name of the configuration section to bind to. In this scenario, the options object provides the name of its configuration section. Then we call the following code to bind the configuration section to the options object and validate the data annotations:

```csharp
builder.Services
    .AddOptions<SettingsOptions>()
    .Bind(Configuration.GetSection(SettingsOptions.ConfigurationSectionName))
    .ValidateDataAnnotations();
```

While this approach works effectively, it can introduce performance implications because validation occurs at runtime via reflection. Additionally, reliance on reflection can lead to issues, particularly when using AOT compilation. Leveraging compile-time source generation for options validation allows you to generate performance-optimized validation code and eliminates the need for reflection, resulting in smoother AOT-compatible app building. The following code demonstrates how to use the options validation source generator:

```csharp
[OptionsValidator]
public partial class ValidateSettingsOptions : IValidateOptions<SettingsOptions>
{
}
```

Employing <xref:Microsoft.Extensions.Options.OptionsValidatorAttribute> on an empty partial class instructs the options validation source generator to create the IValidateOptions interface implementation which validate `SettingsOptions`. The generated code by the options validation source generator will resemble the following example:

```csharp
// <auto-generated/>
#nullable enable
#pragma warning disable CS1591 // Compensate for https://github.com/dotnet/roslyn/issues/54103
partial class ValidateSettingsOptions
{
    /// <summary>
    /// Validates a specific named options instance (or all when <paramref name="name"/> is <see langword="null" />).
    /// </summary>
    /// <param name="name">The name of the options instance being validated.</param>
    /// <param name="options">The options instance.</param>
    /// <returns>Validation result.</returns>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Extensions.Options.SourceGeneration", "42.42.42.42")]
    [System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2026:RequiresUnreferencedCode",
         Justification = "The created ValidationContext object is used in a way that never call reflection")]
    public global::Microsoft.Extensions.Options.ValidateOptionsResult Validate(string? name, global::SettingsOptions options)
    {
        global::Microsoft.Extensions.Options.ValidateOptionsResultBuilder? builder = null;
        var context = new global::System.ComponentModel.DataAnnotations.ValidationContext(options);
        var validationResults = new global::System.Collections.Generic.List<global::System.ComponentModel.DataAnnotations.ValidationResult>();
        var validationAttributes = new global::System.Collections.Generic.List<global::System.ComponentModel.DataAnnotations.ValidationAttribute>(1);

        context.MemberName = "SiteTitle";
        context.DisplayName = string.IsNullOrEmpty(name) ? "SettingsOptions.SiteTitle" : $"{name}.SiteTitle";
        validationAttributes.Add(global::__OptionValidationStaticInstances.__Attributes.A1);
        if (!global::System.ComponentModel.DataAnnotations.Validator.TryValidateValue(options.SiteTitle, context, validationResults, validationAttributes))
        {
            (builder ??= new()).AddResults(validationResults);
        }

        context.MemberName = "Scale";
        context.DisplayName = string.IsNullOrEmpty(name) ? "SettingsOptions.Scale" : $"{name}.Scale";
        validationResults.Clear();
        validationAttributes.Clear();
        validationAttributes.Add(global::__OptionValidationStaticInstances.__Attributes.A2);
        if (!global::System.ComponentModel.DataAnnotations.Validator.TryValidateValue(options.Scale, context, validationResults, validationAttributes))
        {
            (builder ??= new()).AddResults(validationResults);
        }

        return builder is null ? global::Microsoft.Extensions.Options.ValidateOptionsResult.Success : builder.Build();
    }
}
namespace __OptionValidationStaticInstances
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Extensions.Options.SourceGeneration", "42.42.42.42")]
    file static class __Attributes
    {
        internal static readonly global::System.ComponentModel.DataAnnotations.RegularExpressionAttribute A1 = new global::System.ComponentModel.DataAnnotations.RegularExpressionAttribute(
            "^[a-zA-Z''-'\\s]{1,40}$");

        internal static readonly __OptionValidationGeneratedAttributes.__SourceGen__RangeAttribute A2 = new __OptionValidationGeneratedAttributes.__SourceGen__RangeAttribute(
            (int)0,
            (int)1000)
        {
            ErrorMessage = "Value for {0} must be between {1} and {2}."
        };
    }
}
namespace __OptionValidationStaticInstances
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Extensions.Options.SourceGeneration", "42.42.42.42")]
    file static class __Validators
    {
    }
}
namespace __OptionValidationGeneratedAttributes
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Extensions.Options.SourceGeneration", "42.42.42.42")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Property | global::System.AttributeTargets.Field | global::System.AttributeTargets.Parameter, AllowMultiple = false)]
    file class __SourceGen__RangeAttribute : global::System.ComponentModel.DataAnnotations.ValidationAttribute
    {
        public __SourceGen__RangeAttribute(int minimum, int maximum) : base()
        {
            Minimum = minimum;
            Maximum = maximum;
            OperandType = typeof(int);
        }
        public __SourceGen__RangeAttribute(double minimum, double maximum) : base()
        {
            Minimum = minimum;
            Maximum = maximum;
            OperandType = typeof(double);
        }
        public __SourceGen__RangeAttribute(global::System.Type type, string minimum, string maximum) : base()
        {
            OperandType = type;
            NeedToConvertMinMax = true;
            Minimum = minimum;
            Maximum = maximum;
        }
        public object Minimum { get; private set; }
        public object Maximum { get; private set; }
        public bool MinimumIsExclusive { get; set; }
        public bool MaximumIsExclusive { get; set; }
        public global::System.Type OperandType { get; }
        public bool ParseLimitsInInvariantCulture { get; set; }
        public bool ConvertValueInInvariantCulture { get; set; }
        public override string FormatErrorMessage(string name) =>
                string.Format(global::System.Globalization.CultureInfo.CurrentCulture, GetValidationErrorMessage(), name, Minimum, Maximum);
        private bool NeedToConvertMinMax { get; }
        private bool Initialized { get; set; }
        public override bool IsValid(object? value)
        {
            if (!Initialized)
            {
                if (Minimum is null || Maximum is null)
                {
                    throw new global::System.InvalidOperationException("The minimum and maximum values must be set to valid values.");
                }
                if (NeedToConvertMinMax)
                {
                    System.Globalization.CultureInfo culture = ParseLimitsInInvariantCulture ? global::System.Globalization.CultureInfo.InvariantCulture : global::System.Globalization.CultureInfo.CurrentCulture;
                    Minimum = ConvertValue(Minimum, culture) ?? throw new global::System.InvalidOperationException("The minimum and maximum values must be set to valid values.");
                    Maximum = ConvertValue(Maximum, culture) ?? throw new global::System.InvalidOperationException("The minimum and maximum values must be set to valid values.");
                }
                int cmp = ((global::System.IComparable)Minimum).CompareTo((global::System.IComparable)Maximum);
                if (cmp > 0)
                {
                    throw new global::System.InvalidOperationException("The maximum value '{Maximum}' must be greater than or equal to the minimum value '{Minimum}'.");
                }
                else if (cmp == 0 && (MinimumIsExclusive || MaximumIsExclusive))
                {
                    throw new global::System.InvalidOperationException("Cannot use exclusive bounds when the maximum value is equal to the minimum value.");
                }
                Initialized = true;
            }

            if (value is null or string { Length: 0 })
            {
                return true;
            }

            System.Globalization.CultureInfo formatProvider = ConvertValueInInvariantCulture ? global::System.Globalization.CultureInfo.InvariantCulture : global::System.Globalization.CultureInfo.CurrentCulture;
            object? convertedValue;

            try
            {
                convertedValue = ConvertValue(value, formatProvider);
            }
            catch (global::System.Exception e) when (e is global::System.FormatException or global::System.InvalidCastException or global::System.NotSupportedException)
            {
                return false;
            }

            var min = (global::System.IComparable)Minimum;
            var max = (global::System.IComparable)Maximum;

            return
                (MinimumIsExclusive ? min.CompareTo(convertedValue) < 0 : min.CompareTo(convertedValue) <= 0) &&
                (MaximumIsExclusive ? max.CompareTo(convertedValue) > 0 : max.CompareTo(convertedValue) >= 0);
        }
        private string GetValidationErrorMessage()
        {
            return (MinimumIsExclusive, MaximumIsExclusive) switch
            {
                (false, false) => "The field {0} must be between {1} and {2}.",
                (true, false) => "The field {0} must be between {1} exclusive and {2}.",
                (false, true) => "The field {0} must be between {1} and {2} exclusive.",
                (true, true) => "The field {0} must be between {1} exclusive and {2} exclusive.",
            };
        }
        private object? ConvertValue(object? value, System.Globalization.CultureInfo formatProvider)
        {
            if (value is string stringValue)
            {
                value = global::System.Convert.ChangeType(stringValue, OperandType, formatProvider);
            }
            else
            {
                value = global::System.Convert.ChangeType(value, OperandType, formatProvider);
            }
            return value;
        }
    }
}

```

The generated code is optimized for performance and doesn't rely on reflection. The generated code is also AOT-compatible. The generated code is placed in a file named *Validators.g.cs*.

> [!NOTE]
> Users don't need to take any additional steps to enable the options validation source generator. It is automatically enabled by default when referencing [Microsoft.Extensions.Options](https://www.nuget.org/packages/Microsoft.Extensions.Options) version 8 and above in the project or when building an ASP.NET application.

The only step the app developer needs to take is to add the following to the startup code:

```csharp
builder.Services
    .AddSingleton<IValidateOptions<SettingsOptions>, ValidateSettingsOptions>();
```

> [!NOTE]
> Calling `ValidateDataAnnotations` is not required when using the options validation source generator.

When the application attempts to access the options object, the generated code for options validation will be executed to validate the options object. The following code snippet illustrates how to access the options object:

```csharp
    var settingsOptions = app.Services.GetRequiredService<IOptions<SettingsOptions>>().Value;
```

## Replaced data annotation attributes

Upon close examination of the generated code, you'll observe that the original data annotation attributes, such as <xref:System.ComponentModel.DataAnnotations.RangeAttribute> which were initially applied to the property `SettingsOptions.Scale`, have been substituted with custom attributes like `__SourceGen__RangeAttribute`. This substitution is made because the `RangeAttribute` relies on reflection for validation. In contrast, `__SourceGen__RangeAttribute` is a custom attribute optimized for performance and doesn't depend on reflection, making the code AOT-compatible. The same pattern of attribute replacement will be applied on <xref:System.ComponentModel.DataAnnotations.MaxLengthAttribute>, <xref:System.ComponentModel.DataAnnotations.MinLengthAttribute>, and <xref:System.ComponentModel.DataAnnotations.LengthAttribute> in addition to <xref:System.ComponentModel.DataAnnotations.RangeAttribute>.
For anyone developing custom data annotation attributes, it is advisable to refrain from using reflection for validation. Instead, it's recommended to craft strongly typed code that does not rely on reflection. This approach ensures smooth compatibility with AOT builds.

## See also

[Options pattern](options.md)
