#nullable enable

using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GenerateMembersGenerator;

// <GenerateMembersGenerator>
/// <summary>
/// A source generator that adds a <c>Describe()</c> method and a
/// <c>PropertyNames</c> list to any <see langword="partial"/> class or struct
/// decorated with <c>[GenerateMembers]</c>.
/// </summary>
[Generator]
public class GenerateMembersIncrementalGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "GenerateMembersGenerator.GenerateMembersAttribute";

    // <Initialize>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Emit the marker attribute so users don't need a separate reference.
        context.RegisterPostInitializationOutput(static ctx =>
        {
            ctx.AddSource("GenerateMembersAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // 2. Filter for type declarations annotated with [GenerateMembers].
        IncrementalValuesProvider<TypeInfo> typeInfos = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeFullName,
                predicate: static (node, _) => node is TypeDeclarationSyntax,
                transform: static (ctx, _) => GetTypeInfo(ctx))
            .Where(static t => t is not null)!;

        // 3. Generate source for each qualifying type.
        context.RegisterSourceOutput(typeInfos, static (spc, typeInfo) =>
        {
            string source = GenerateSource(typeInfo);
            string hintName = typeInfo.FullyQualifiedName
                .Replace("global::", "")
                .Replace("::", ".")
                .Replace("<", "_")
                .Replace(">", "_");
            spc.AddSource($"{hintName}.GeneratedMembers.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }
    // </Initialize>

    // <GetTypeInfo>
    private static TypeInfo? GetTypeInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
            return null;

        string typeKeyword = context.TargetNode is StructDeclarationSyntax ? "struct" : "class";

        ImmutableArray<IPropertySymbol> properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && !p.IsIndexer)
            .ToImmutableArray();

        return new TypeInfo(
            typeSymbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : typeSymbol.ContainingNamespace.ToDisplayString(),
            typeSymbol.Name,
            typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            typeKeyword,
            properties.Select(p => (p.Name, p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
                      .ToImmutableArray());
    }
    // </GetTypeInfo>

    // <GenerateSource>
    private static string GenerateSource(TypeInfo typeInfo)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");

        if (typeInfo.Namespace is not null)
        {
            sb.AppendLine($"namespace {typeInfo.Namespace}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"    partial {typeInfo.TypeKeyword} {typeInfo.Name}");
        sb.AppendLine("    {");

        // PropertyNames
        sb.AppendLine("        /// <summary>Gets the names of all instance properties.</summary>");
        sb.AppendLine("        public static global::System.Collections.Generic.IReadOnlyList<string> PropertyNames { get; } =");
        sb.Append("            new string[] { ");
        sb.Append(string.Join(", ", typeInfo.Properties.Select(p => $"\"{p.Name}\"")));
        sb.AppendLine(" };");
        sb.AppendLine();

        // Describe method
        sb.AppendLine("        /// <summary>Returns a human-readable description of this instance.</summary>");
        sb.AppendLine("        public string Describe()");
        sb.AppendLine("        {");
        sb.AppendLine($"            var sb = new global::System.Text.StringBuilder();");
        sb.AppendLine($"            sb.AppendLine(\"{typeInfo.Name}\");");
        foreach (var (name, _) in typeInfo.Properties)
        {
            sb.AppendLine($"            sb.AppendLine($\"  {name} = {{{name}}}\");");
        }
        sb.AppendLine("            return sb.ToString();");
        sb.AppendLine("        }");

        sb.AppendLine("    }");

        if (typeInfo.Namespace is not null)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }
    // </GenerateSource>

    // <AttributeSource>
    private const string AttributeSource = @"// <auto-generated />
namespace GenerateMembersGenerator
{
    /// <summary>
    /// Add this attribute to a partial class or struct to automatically generate
    /// a <c>Describe()</c> method and a <c>PropertyNames</c> list.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct)]
    internal sealed class GenerateMembersAttribute : global::System.Attribute
    {
    }
}
";
    // </AttributeSource>

    // <TypeInfoClass>
    private sealed class TypeInfo
    {
        public string? Namespace { get; }
        public string Name { get; }
        public string FullyQualifiedName { get; }
        public string TypeKeyword { get; }
        public ImmutableArray<(string Name, string TypeFullName)> Properties { get; }

        public TypeInfo(
            string? ns,
            string name,
            string fullyQualifiedName,
            string typeKeyword,
            ImmutableArray<(string Name, string TypeFullName)> properties)
        {
            Namespace = ns;
            Name = name;
            FullyQualifiedName = fullyQualifiedName;
            TypeKeyword = typeKeyword;
            Properties = properties;
        }
    }
    // </TypeInfoClass>
}
// </GenerateMembersGenerator>
