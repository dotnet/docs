// <HelloFromGenerator>
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MySourceGenerator;

[Generator]
public class HelloFromGenerator : IIncrementalGenerator
{
    // <AttributeSource>
    private const string HelloFromAttributeSource = @"// <auto-generated/>
namespace MySourceGenerator
{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class HelloFromAttribute : System.Attribute
    {
    }
}";
    // </AttributeSource>

    // <Initialize>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Inject the marker attribute into the user's compilation.
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource("HelloFromAttribute.g.cs",
                SourceText.From(HelloFromAttributeSource, Encoding.UTF8)));

        // Create a syntax provider that filters to class declarations
        // with at least one attribute.
        IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsCandidateClass(s),
                    transform: static (ctx, _) => GetSemanticTarget(ctx))
                .Where(static m => m is not null)!;

        // Combine the selected classes with the compilation.
        IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)>
            compilationAndClasses = context.CompilationProvider
                .Combine(classDeclarations.Collect());

        // Generate source code for each matching class.
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Item1, source.Item2, spc));
    }
    // </Initialize>

    // <Predicate>
    private static bool IsCandidateClass(SyntaxNode node) =>
        node is ClassDeclarationSyntax c && c.AttributeLists.Count > 0;
    // </Predicate>

    // <Transform>
    private static ClassDeclarationSyntax? GetSemanticTarget(
        GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (AttributeListSyntax attributeList in classDeclaration.AttributeLists)
        {
            foreach (AttributeSyntax attribute in attributeList.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attribute).Symbol
                        is not IMethodSymbol attributeSymbol)
                {
                    continue;
                }

                string fullName = attributeSymbol.ContainingType.ToDisplayString();

                if (fullName == "MySourceGenerator.HelloFromAttribute")
                {
                    return classDeclaration;
                }
            }
        }

        return null;
    }
    // </Transform>

    // <Execute>
    private static void Execute(
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classes,
        SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
        {
            return;
        }

        foreach (ClassDeclarationSyntax classDeclaration in classes.Distinct())
        {
            SemanticModel semanticModel =
                compilation.GetSemanticModel(classDeclaration.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclaration)
                    is not INamedTypeSymbol classSymbol)
            {
                continue;
            }

            string namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
                ? string.Empty
                : classSymbol.ContainingNamespace.ToDisplayString();
            string className = classSymbol.Name;

            string source = string.IsNullOrEmpty(namespaceName)
                ? $@"// <auto-generated/>
partial class {className}
{{
    public static string HelloFrom() =>
        ""Hello from '{className}'"";
}}"
                : $@"// <auto-generated/>
namespace {namespaceName}
{{
    partial class {className}
    {{
        public static string HelloFrom() =>
            ""Hello from '{className}'"";
    }}
}}";

            context.AddSource(
                $"{className}.HelloFrom.g.cs",
                SourceText.From(source, Encoding.UTF8));
        }
    }
    // </Execute>
}
// </HelloFromGenerator>
