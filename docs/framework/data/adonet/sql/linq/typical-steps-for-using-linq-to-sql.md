---
description: "Learn more about: Typical Steps for Using LINQ to SQL"
title: "Typical Steps for Using LINQ to SQL"
ms.date: "03/30/2017"
ms.assetid: 9a88bd51-bd74-48f7-a9b1-f650e8d55a3e
---
# Typical Steps for Using LINQ to SQL

To implement a [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] application, you follow the steps described later in this topic. Note that many steps are optional. It is very possible that you can use your object model in its default state.  
  
 For a really fast start, use the Object Relational Designer to create your object model and start coding your queries.  
  
## Creating the Object Model  

 The first step is to create an object model from the metadata of an existing relational database. The object model represents the database according to the programming language of the developer. For more information, see [The LINQ to SQL Object Model](the-linq-to-sql-object-model.md).  
  
### 1. Select a tool to create the model.  

 Three tools are available for creating the model.  
  
- The Object Relational Designer  
  
     This designer provides a rich user interface for creating an object model from an existing database. This tool is part of the Visual Studio IDE, and is best suited to small or medium databases.  
  
- The SQLMetal code-generation tool  
  
     This command-line utility provides a slightly different set of options from the O/R Designer. Modeling large databases is best done by using this tool. For more information, see [SqlMetal.exe (Code Generation Tool)](../../../../tools/sqlmetal-exe-code-generation-tool.md).  
  
- A code editor  
  
     You can write your own code by using either the Visual Studio code editor or another editor. We do not recommend this approach, which can be prone to errors, when you have an existing database and can use either the O/R Designer or the SQLMetal tool. However, the code editor can be valuable for refining or modifying code you have already generated by using other tools. For more information, see [How to: Customize Entity Classes by Using the Code Editor](how-to-customize-entity-classes-by-using-the-code-editor.md).  
  
### 2. Select the kind of code you want to generate.  
  
- A C# or Visual Basic source code file for attribute-based mapping.  
  
     You then include this code file in your Visual Studio project. For more information, see [Attribute-Based Mapping](attribute-based-mapping.md).  
  
- An XML file for external mapping.  
  
     By using this approach, you can keep the mapping metadata out of your application code. For more information, see [External Mapping](external-mapping.md).  
  
    > [!NOTE]
    > The O/R Designer does not support the generation of external mapping files. You must use the SQLMetal tool to implement this feature.  
  
- A DBML file, which you can modify before generating a final code file.  
  
     This is an advanced feature.  
  
### 3. Refine the code file to reflect the needs of your application.  

 For this purpose, you can use either the O/R Designer or the code editor.  
  
## Using the Object Model  

 The following illustration shows the relationship between the developer and the data in a two-tier scenario. For other scenarios, see [N-Tier and Remote Applications with LINQ to SQL](n-tier-and-remote-applications-with-linq-to-sql.md).  
  
 ![Screenshot that shows the Linq Object Model.](./media/the-linq-to-sql-object-model/linq-object-model-two-tier.png)  
  
 Now that you have the object model, you describe information requests and manipulate data within that model. You think in terms of the objects and properties in your object model and not in terms of the rows and columns of the database. You do not deal directly with the database.  
  
 When you instruct [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] to either execute a query that you have described or call `SubmitChanges()` on data that you have manipulated, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] communicates with the database in the language of the database.  
  
 The following represents typical steps for using the object model that you have created.  
  
### 1. Create queries to retrieve information from the database.  

 For more information, see [Query Concepts](query-concepts.md) and [Query Examples](query-examples.md).  
  
### 2. Override default behaviors for Insert, Update, and Delete.  

 This step is optional. For more information, see [Customizing Insert, Update, and Delete Operations](customizing-insert-update-and-delete-operations.md).  
  
### 3. Set appropriate options to detect and report concurrency conflicts.  

 You can leave your model with its default values for handling concurrency conflicts, or you can change it to suit your purposes. For more information, see [How to: Specify Which Members are Tested for Concurrency Conflicts](how-to-specify-which-members-are-tested-for-concurrency-conflicts.md) and [How to: Specify When Concurrency Exceptions are Thrown](how-to-specify-when-concurrency-exceptions-are-thrown.md).  
  
### 4. Establish an inheritance hierarchy.  

 This step is optional. For more information, see [Inheritance Support](inheritance-support.md).  
  
### 5. Provide an appropriate user interface.  

 This step is optional, and depends on how your application will be used.  
  
### 6. Debug and test your application.  

 For more information, see [Debugging Support](debugging-support.md).  
  
## See also

- [Getting Started](getting-started.md)
- [Creating the Object Model](creating-the-object-model.md)
- [Stored Procedures](stored-procedures.md)
