---
title: "Service Framework"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: 75f60b87-f80e-4377-ba7c-8e6becaa2b28
caps.latest.revision: 6
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
ms.workload: 
  - "dotnet"
---
# Service Framework
This topic lists all exceptions generated by Service Framework Data.  
  
## Exception List  
  
|Resource Code|Resource String|  
|-------------------|---------------------|  
|ABindingInstanceHasAlreadyBeenAssociatedTo1|A binding instance has already been associated to listen the specified uniform resource identifier. If two endpoints want to share the same ListenUniform resource indicator, they must also share the same binding object instance. The two conflicting endpoints were specified in AddServiceEndpoint() calls, in a configuration file, or a combination of AddServiceEndpoint() and configuration.|  
|AChannelServiceEndpointIsNull0|A channel or service endpoint is null.|  
|AChannelServiceEndpointSContractSNameIsNull0|A Channel/Service endpoint contract name is null or empty.|  
|AChannelServiceEndpointSContractSNamespace0|A Channel/Service endpoint contract namespace is null.|  
|BaseAddressCannotHaveFragment|A base address cannot contain a uniform resource identifier fragment.|  
|BaseAddressCannotHaveQuery|A base address cannot contain a uniform resource identifier query string.|  
|BaseAddressCannotHaveUserInfo|A base address cannot contain a uniform resource identifier user information section.|  
|BaseAddressDuplicateScheme|This collection already contains an address with the specified scheme. Only one address is allowed for each scheme in this collection.|  
|BaseAddressMustBeAbsolute|Only an absolute uniform resource identifier can be used as a base address.|  
|BindingDoesnTSupportAnyChannelTypes1|The specified binding does not support creating any channel types. The binding elements in a custom binding are incorrectly stacked or in the wrong order. A transport is required at the bottom for the stack. The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.|  
|BindingDoesnTSupportDuplexButContractRequires1|Contract requires Duplex. The specified binding does not support it or is not configured properly to support it.|  
|BindingDoesnTSupportOneWayButContractRequires1|Contract requires OneWay. The specified binding does not support it or is not configured properly to support it.|  
|BindingDoesnTSupportRequestReplyButContract1|Contract requires Request/Reply. The specified binding does not support it or is not configured properly to support it.|  
|BindingDoesnTSupportSessionButContractRequires1|Contract requires Session.  The specified binding does not support it or is not configured properly to support it.|  
|BindingDoesnTSupportTwoWayButContractRequires1|Contract requires Two-Way (either request-reply or duplex). The specified binding does not support it or is not configured properly to support it.|  
|BindingRequirementsAttributeDisallowsQueuedDelivery1|DeliveryRequirementsAttribute does not allow QueuedDelivery. The binding for the endpoint with the specified contract supports it.|  
|BindingRequirementsAttributeRequiresQueuedDelivery1|DeliveryRequirementsAttribute requires QueuedDelivery. The binding for the endpoint with the specified contract does not support it or is not configured properly to support it.|  
|channelDoesNotHaveADuplexSession0|The current channel does not support closing the output session. This channel does not implement ISessionChannel\<IDuplexSession>.|  
|ClientRuntimeRequiresFormatter0|The specified ClientOperation requires a formatter, because SerializeRequest and DeserializeReply are not both false.|  
|CommunicationObjectAborted1|The specified communication object cannot be used for communication because it has been stopped.|  
|CommunicationObjectAbortedStack2|The specified communication object cannot be used for communication because it has been stopped: {1}|  
|CommunicationObjectBaseClassMethodNotCalled|The specified communication object has overridden the virtual function {1} but it does not call the version defined in the base class.|  
|ContractIsNotSelfConsistentItHasOneOrMore2|The specified contract has one or more IsTerminating or non-IsInitiating operations. It does not have the SessionMode property set to SessionMode.Required. The IsInitiating and IsTerminating attributes can only be used in the context of a session.|  
|CouldnTCreateChannelForChannelType2|The specified channel type was requested, but the specified binding does not support it or is not configured properly to support it.|  
|DispatchRuntimeRequiresFormatter0|The specified DispatchOperation requires a Formatter, because DeserializeRequest and SerializeReply are not both false.|  
|EndMethodsCannotBeDecoratedWithOperationContractAttribute|The End method cannot be used with OperationContractAttribute when using the IAsyncResult design pattern. Only the corresponding Begin method can be used with OperationContractAttribute. That attribute applies to the Begin-End pair of methods.|  
|EndpointListenerRequirementsCannotBeMetBy3|The ChannelDispatcher requirements cannot be met by the IChannelListener for the specified binding because the contract requires support for one of these specified channel types. But the binding only supports these specified channel types.|  
|EndpointsMustHaveAValidBinding0|Endpoints must have a valid binding.|  
|InvalidOrUnrecognizedAction|The message cannot be processed because the specified action is invalid or unrecognized.|  
|MultipleMebesInParameters|More than one MessageEncodingBindingElement was found in the BindingParameters of the BindingContext. CustomBinding cannot have multiple MessageEncodingBindingElements. Remove all but one of these elements.|  
|MultipleStreamUpgradeProvidersInParameters|More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext. CustomBinding cannot have more than one IStreamUpgradeProviderElements. Remove all but one of these elements.|  
|NoChannelBuilderAvailable|The binding cannot be used to create a channel factory or a channel listener because it does not have a TransportBindingElement. Every binding must have at least one binding element that derives from TransportBindingElement.|  
|NotAllBindingElementsBuilt|Some of the binding elements in this binding were not used when building the channel factory and channel listener. The binding elements are not ordered correctly. The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.  Note that the TransportBindingElement must be last. The specified binding elements were not built.|  
|RuntimeRequiresInvoker0|The dispatch operation requires an invoker.|  
|ServiceHasZeroAppEndpoints|The specified Service has no application (non-infrastructure) endpoints. This might be because no configuration file was found for your application or because no service element matching the service name could be found in the configuration file or because no endpoints were defined in the service element.|  
|SFxActionMismatch|Cannot create a typed message due to an action mismatch. Expecting the specified action but encountered another|  
|SFxAnonymousTypeNotSupported|The specified part in the specified message cannot be exported with RPC or encoded because its type is anonymous.|  
|SFxBadMetadataLocationNoAppropriateBaseAddress|The URL supplied to ServiceMetadataBehavior using the ExternalMetadataLocation property or the externalMetadataLocation attribute in the serviceMetadata section in the configuration section was a relative URL and there is no base address with which to resolve it.|  
|SFxBadMetadataMustBePolicy|Must provide a policy XmlElement that has the specified namespace and name. This XmlElement has the specified namespace and name.|  
|SFxBodyObjectTypeCannotBeInherited|The specified type cannot inherit from any class other than the object to be used as the body object in RPC style.|  
|SFxBodyObjectTypeCannotBeInterface|The specified type implements the specified interface, which is not supported for the body object in RPC style.|  
|SFxCallbackBehaviorAttributeOnlyOnDuplex|CallbackBehaviorAttribute can only be run as a behavior on an endpoint with a duplex contract. The specified contract is not duplex and contains no callback operations.|  
|SFxCallbackRequestReplyInOrder1|The reply cannot be received from this operation until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on the specified.|  
|SfxCallbackTypeCannotBeNull|In order to use the specified contract with DuplexChannelFactory, the contract must specify a valid callback contract. If your contract does have a callback contract, use ChannelFactory instead of DuplexChannelFactory.|  
|SFxCannotGetMetadataFromLocation|The MetadataExchangeClient can only get metadata from HTTP and HTTPS MetadataLocations. It cannot get metadata from the specified.|  
|SFxCannotHttpGetMetadataFromAddress|The MetadataExchangeClient can only get metadata from HTTP or HTTPS addresses when using MetadataExchangeClientMode HttpGet. It cannot get metadata from the specified.|  
|SFxCannotImportAsParameters_Bare|Generating message contract because the specified operation is neither RPC nor document wrapped.|  
|SFxCannotImportAsParameters_DifferentWrapperName|Generating message contract because the wrapper name of the specified message does not match the default value.|  
|SFxCannotImportAsParameters_DifferentWrapperNs|Generating message contract because the wrapper namespace of the specified message does not match the default value.|  
|SFxCannotImportAsParameters_ElementIsNotNillable|Generating a message contract because the specified element name from the specified namespace is not marked nillable.|  
|SFxCannotImportAsParameters_HeadersAreUnsupported|Generating message contract because the specified message has headers.|  
|SFxCannotImportAsParameters_Message|Generating a message contract because the specified operation has an untyped Message as argument or return type.|  
|SFxCannotImportAsParameters_MessageHasProtectionLevel|Generating message contract because the specified message requires protection.|  
|SFxCannotImportAsParameters_NamespaceMismatch|Generating message contract because the specified message part namespace does not match the default value.|  
|SFxCannotRequireBothSessionAndDatagram3|The specified contract specifies SessionMode.NotAllowed and the specified contract specifies SessionMode.Required. Change one of the SessionMode values or specify a different address, or ListenURI, for each endpoint.|  
|SFxCannotSetExtensionsByIndex|This collection does not support setting extensions by index. Use the InsertItem or RemoveItem methods.|  
|SFxChannelDispatcherDifferentHost0|The ChannelDispatcher is not currently attached to the ServiceHost that was provided.|  
|SFxChannelDispatcherMultipleHost0|The ChannelDispatcher cannot be added to more than one ServiceHost.|  
|SFxChannelDispatcherNoHost0|The ChannelDispatcher cannot be opened because it is not attached to a ServiceHost.|  
|SfxChannelFactoryDisposed|This ChannelFactory cannot be opened as the ChannelFactory has already been disposed. Create the ChannelFactory again before using it.|  
|SFxChannelFactoryNoBinding|The ChannelFactory cannot be opened because no binding has been associated with its endpoint. Specify a binding with the constructor or the endpoint property.|  
|SFxChannelTerminated0|An operation marked as IsTerminating has already been invoked on this channel, causing the channel connection to terminate. No more operations may be invoked on this channel. Re-create the channel to continue communication.|  
|SFxCloseTimedOut1|The ServiceHost close operation stopped after the specified. This could be because a client failed to close a sessionful channel within the required time. The time allowed for this operation may have been part of a longer timeout.|  
|SfxCloseTimedOutWaitingForDispatchToComplete|The close process timed out while waiting for the service dispatch to complete.|  
|SFxCodeGenIsNotAssignableFrom|The specified cannot be assigned.|  
|SFxConfigChannelConfigurationNotFound|The endpoint element with the specified name and contract in the ServiceModel client configuration section cannot be found.|  
|SFxConflictingGlobalElement|The top-level Extensible Markup Language element with the specified name in the specified namespace cannot reference the specified type. It already references a different type. Use a different operation name or MessageBodyAttribute to specify a different name for the message or message parts.|  
|SFxContractHasZeroInitiatingOperations|A contract must have at least one IsInitiating=true operation.|  
|SFxContractHasZeroOperations|A contract must have at least one operation.|  
|SFxContractInheritanceRequiresInterfaces|The service class of the specified type defines a ServiceContract and inherits a ServiceContract from the specified type. Contract inheritance can only be used among interface types. If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Move the ServiceContractAttribute on the specified type to a separate interface that the specified type implements.|  
|SFxCreateDuplexChannel1|The callback contract of the specified contract either does not exist or does not define any operations. If this is not a duplex contract, use ChannelFactory instead of DuplexChannelFactory.|  
|SFxCreateDuplexChannelNoCallback|This CreateChannel overload cannot be called on this instance of DuplexChannelFactory. The DuplexChannelFactory was not initialized with an InstanceContext. Call the CreateChannel overload that takes an InstanceContext.|  
|SFxCreateDuplexChannelNoCallback1|This CreateChannel overload cannot be called on this instance of DuplexChannelFactory. The DuplexChannelFactory was initialized with a Type and no valid InstanceContext was provided. Call the CreateChannel overload that takes an InstanceContext.|  
|SFxCreateDuplexChannelNoCallbackUserObject|This CreateChannel overload cannot be called on this instance of DuplexChannelFactory. The InstanceContext provided to the DuplexChannelFactory does not contain a valid UserObject.|  
|SFxCreateNonDuplexChannel1|ChannelFactory does not support the specified contract. ChannelFactory defines a callback contract with one or more operations. Use DuplexChannelFactory instead of ChannelFactory.|  
|SFxCustomBindingNeedsTransport1|The CustomBinding on the ServiceEndpoint with the specified contract does not have a TransportBindingElement. Every binding must have at least one binding element that derives from TransportBindingElement.|  
|SFxCustomBindingWithoutTransport|The Scheme cannot be computed for this custom binding because it does not have a TransportBindingElement. Every binding must have at least one binding element that derives from TransportBindingElement.|  
|SFxDataContractSerializerDoesNotSupportBareArray|DataContractSerializer does not support the collection specified on the specified element.|  
|SFxDictionaryIsEmpty|The operation cannot be performed because the dictionary is empty.|  
|SFxDocEncodedNotSupported|Error reflecting the specified. Document-Encoded is not supported. Change 'Use' to Literal or 'Style' to RPC.|  
|SFxDuplicateInitiatingActionAtSameVia|This service has multiple endpoints listening at the specified. The endpoints share the same specified initiating action. Messages with this action would be dropped because the dispatcher would not be able to determine the correct endpoint for handling the message.|  
|SFXEndpointBehaviorUsedOnWrongSide|The specified IEndpointBehavior cannot be used on the server. This behavior can only applies to clients.|  
|SFxEndpointNoMatchingScheme|The base address that matches the specified scheme for the endpoint with the specified binding cannot be found. Registered base address schemes are specified.|  
|SFxErrorCreatingMtomReader|An error occurred while creating a reader for the message transmission optimization mechanism message.|  
|SFxErrorDeserializingFault|The server returned an invalid simple object access protocol fault. See InnerException for more details.|  
|SFxErrorDeserializingHeader|An error occurred while deserializing one of the headers in the specified message. Please see InnerException for more details.|  
|SFxErrorReflectingOnMethod3|An error occurred while loading the specified attribute on the specified method in the specified type.  See InnerException for more details.|  
|SFxErrorReflectingOnParameter4|An error occurred while loading the specified attribute on the specified parameter of the specified method in the specified type. See InnerException for more details.|  
|SFxErrorReflectingOnType2|An error occurred while loading the specified attribute on the specified type.  See InnerException for more details.|  
|SFxErrorSerializingBody|There was an error serializing the body of the specified message. See InnerException for more details.|  
|SFxErrorSerializingHeader|An error occurred while serializing one of the headers in the specified message. See InnerException for more details.|  
|SFxExpectedIMethodCallMessage|Internal Error. The message must be a valid IMethodCallMessage.|  
|SFxExportMustHaveType|The specified Part in the specified operation cannot be exported because it does not have a valid CLR type.|  
|SFxHeaderNotUnderstood|The message was not processed. The specified header from the specified namespace was not understood by the recipient of this message. This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process. Ensure that the configuration of the client's binding is consistent with the service's binding.|  
|SFxHeadersAreNotSupportedInEncoded|The specified message must not have headers to be used in the remote procedure call encoded style.|  
|SFxInconsistentWsdlOperationStyleInMessageParts|All parts of the message in the specified operation must either contain a type or an element.|  
|SFxInconsistentWsdlOperationStyleInOperationMessages|The specified style inferred from the messages in the specified operation does not match the specified expected style specified using bindings.|  
|SFxInvalidCallbackIAsyncResult|IAsyncResult is not provided or is of the wrong type.|  
|SFxInvalidMessageBody|The OperationFormatter encountered an invalid message body. The 'Element' node type with the specified name and namespace was expected. The specified node type with the specified name and namespace was found.|  
|SFxInvalidMessageBodyEmptyMessage|The OperationFormatter cannot deserialize any information from the message because the message is empty.|  
|SFxInvalidMessageBodyErrorDeserializingParameter|An error occurred while trying to deserialize the specified parameter. See InnerException for more information.|  
|SFxInvalidMessageBodyErrorSerializingParameter|An error occurred while trying to serialize the specified parameter. The InnerException message was specified.  See InnerException for more details.|  
|SFxInvalidMessageBodyUnexpectedNode|Encountered the specified unexpected node, from the specified namespace while deserializing parameters.|  
|SFxInvalidMessageContractSignature|The specified operation has either a parameter or a return type that is marked with the MessageContractAttribute. When using a message contract to represent a request message, the operation must have a single parameter that is marked with the MessageContractAttribute. When using a message contract to represent the response message, the operation's return value must be a type that is marked with the MessageContractAttribute. The operation cannot have any 'out' or 'ref' parameters.|  
|SFxInvalidReplyAction|The outgoing reply message for the operation has the specified Action, but the contract for that operation specifies another ReplyAction. The Action specified in the message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.|  
|SFxInvalidRequestAction|The outgoing request message for the operation has the specified Action, but the contract for that operation specifies another RequestAction. The Action specified in the message must match the RequestAction in the contract, or the operation contract must specify RequestAction='*'.|  
|SFxInvalidStaticOverloadCalledForDuplexChannelFactory1|The static CreateChannel method cannot be used with the specified contract because that contract defines a callback contract. Use one of the static CreateChannel overloads on DuplexChannelFactory\<TChannel>.|  
|SFxInvalidStreamInRequest|For the request in the specified operation to be a stream, the operation must have a single parameter whose type is Stream.|  
|SFxInvalidStreamInResponse|For the response in the specified operation to be a stream, the operation must have a single out parameter or return value whose type is Stream.|  
|SFxInvalidStreamInTypedMessage|To use streams with the Message Contract programming model, the specified type must have a single MessageBody member whose type is Stream.|  
|SFxInvalidUseOfPrimitiveOperationFormatter|The PrimitiveOperationFormatter was given a parameter or return type that it does not support.|  
|SFxMessageContractBaseTypeNotValid|The specified type defines a MessageContract and derives from a specified type that does not define a MessageContract. All of the objects in the specified inheritance hierarchy must define a MessageContract.|  
|SFxMethodNotSupported1|The specified method is not supported on this object. This can happen if the method is not marked with OperationContractAttribute or if the interface type is not marked with ServiceContractAttribute.|  
|SFxMethodNotSupportedByType2|The specified ServiceHost implementation type does not implement the specified service contract.|  
|SFxMethodNotSupportedOnCallback1|The specified callback method is not supported. This can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute CallbackContract.|  
|SFxMismatchedOperationParent|A DispatchOperation or ClientOperation can only be added to its parent DispatchRuntime or ClientRuntime respectively.|  
|SFxNameCannotBeEmpty|The Name property cannot be an empty string.|  
|SfxNoTypeSpecifiedForParameter|No CLR type was specified for the parameter, which prevents the operation from being generated.|  
|SFxOperationBehaviorAttributeOnlyOnServiceClass|OperationBehaviorAttribute can only go on the service class. It cannot be put on the ServiceContract interface. The specified method on the specified type violates this.|  
|SFxOperationContractOnNonServiceContract|The specified method is marked with OperationContractAttribute, but the enclosing specified type is not marked with ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.|  
|SFxParameterCountMismatch|A mismatch between the number of supplied arguments and the number of expected arguments occurred. Specifically, the specified argument has the specified number of elements while the expected argument has the specified number of elements.|  
|SFxPartNameMustBeUniqueInRpc|The specified message part name is not unique in a remote procedure call message.|  
|SFxReplyActionMismatch3|A reply message was received for the specified operation with the specified action. However, your client code requires the specified action.|  
|SFxRequestReplyNone|A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the "None" address. These values are not valid for request-reply operations. Use a one-way operation or enable ManualAddressing if you need to support ReplyTo or FaultTo values of "None".|  
|SFxRequestTimedOut1|This request operation did not receive a reply within the specified configured time. The time allowed may have been part of a longer timeout. This may be because the service is still processing the operation or because the service was unable to send a reply message.|  
|SFxRequestTimedOut2|The request operation sent to the specified location did not receive a reply within the specified configured time. The time allowed may have been part of a longer timeout. This may be because the service is still processing the operation or because the service was unable to send a reply message.|  
|SFxSchemaDoesNotContainType|Schema with the specified target namespace does not contain a type with the specified name.|  
|SfxServiceContractAttributeNotFound|The specified contract type is not attributed with ServiceContractAttribute. To define a valid contract, the specified type must be attributed with ServiceContractAttribute. The type can either be a contract interface or a service class.|  
|SFxServiceContractGeneratorConfigRequired|To generate configuration information using the GenerateServiceEndpoint method, the ServiceContractGenerator instance must be initialized with a valid Configuration object.|  
|SFxServiceHostBaseCannotAddEndpointAfterOpen|Endpoints cannot be added after the ServiceHost is in one of the following states:<br /><br /> -   Opened<br />-   Faulted<br />-   Terminated<br />-   Closed|  
|SFxServiceHostBaseCannotAddEndpointWithoutDescription|Endpoints cannot be added before the Description property is initialized.|  
|SFxServiceMetadataBehaviorNoHttpBaseAddress|The HttpGetEnabled property of ServiceMetadataBehavior is set to true and the HttpGetUrl property is a relative address, but there is no HTTP base address. Either supply an HTTP base address or set HttpGetUrl to an absolute address.|  
|SFxServiceMetadataBehaviorNoHttpsBaseAddress|The HttpsGetEnabled property of ServiceMetadataBehavior is set to true and the HttpsGetUrl property is a relative address, but there is no HTTPS base address. Either supply an HTTPS base address or set HttpsGetUrl to an absolute address.|  
|SFxServiceMetadataBehaviorUrlMustBeHttpOrRelative|The behavior Url must be a relative uniform resource identifier or an absolute uniform resource identifier with the specified scheme. The specified Url is an absolute uniform resource identifier with the specified scheme.|  
|SFxStreamRequestMessageClosed|The message that contains this stream has been closed. Request streams cannot be accessed after the service operation returns.|  
|SFxStreamResponseMessageClosed|The message that contains this stream has been closed.|  
|SFxTerminateRequestProcessingException|An extension in the operation pipeline must quit processing this message.|  
|SFxTerminatingOperationAlreadyCalled1|This channel cannot send any more messages because the IsTerminating operation was called.|  
|SFxThrottleLimitMustBeGreaterThanZero0|The throttle limit must be greater than zero. To disable the throttle limit, set the value to Int32.MaxValue.|  
|SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc|When using the RPC-encoded style, message contract types or the System.ServiceModel.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to the specified operation.|  
|SFxUserCodeThrewException|The specified user operation threw an exception that is unhandled in user code. If this is a recurring problem, it may indicate an error in the implementation of the specified method.|  
|SfxUseTypedMessageForCustomAttributes|The specified parameter cannot be mapped to the operation parameter because it requires additional attributes.|  
|SFxVersionMismatchInOperationContextAndMessage2|Cannot add outgoing headers to message because MessageVersion in OperationContext.Current does not match with the header version of message being processed|  
|SFxWellKnownNonSingleton0|To use one of the ServiceHost constructors that takes a service instance, the InstanceContextMode of the service must be set to InstanceContextMode.Single. This can be configured using the ServiceBehaviorAttribute. Otherwise, use the ServiceHost constructors that take a Type argument.|  
|SFxWrapperTypeHasMultipleNamespaces|Wrapper type for the specified message cannot be projected as a data contract type because it has multiple namespaces. Use the XmlSerializer.|  
|UriMustBeAbsolute|The URI must be absolute.|
