---
title: "CA2020: Prevent behavioral change caused by built-in operators of IntPtr/UIntPtr"
description: "Learn about code analysis rule CA2020 - Some built in operators added in .NET 7 behave differently than the user defined operators in .NET 6 and below. Some operators that used to throw in unchecked context while overflowing will not throw anymore unless wrapped within checked context, and some operators that not used to throw in checked context now would throw unless wrapped within unchecked context"
ms.date: 10/07/2022
ms.topic: reference
f1_keywords:
  - PreventNumericIntPtrUIntPtrBehavioralChanges 
  - CA2020
helpviewer_keywords:
  - PreventNumericIntPtrUIntPtrBehavioralChanges 
  - CA2020
author: buyaa-n
---
# CA2020: Prevent behavioral change caused by built-in operators of IntPtr/UIntPtr

| | Value |
|-|-|
| **Rule ID** |CA2020|
| **Category** |[Reliability](reliability-warnings.md)|
| **Fix is breaking or non-breaking** |Non-breaking|

## Cause

This rule fires when it detects a behavioral change between .NET 6.0 and .NET 7.0 introduced with new built-in operators of numeric IntPtr/UIntPtr feature.

## Rule description

With the [numeric IntPtr feature](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/numeric-intptr.md), System.IntPtr and System.UIntPtr gained some built-in operators (conversions, unary and binary). Those now might throw when overflowing within checked context or may not throw in unchecked context compared to the previous `user-defined` operators in .NET 6.0 and below, which could cause behavioral change when upgrading from .NET 6.0 and below into .NET 7.

### List of APIs affected

| Operator | context | in .NET 7.0 | in NET 6.0 and below | Example |
|---|---|---|---|---|
| operator +(IntPtr, int) | checked | throws when overflows | do not throw when overflow | `checked(intPtrVariable + 2);` |
| operator -(IntPtr, int) | checked | throws when overflows | do not throw when overflow | `checked(intPtrVariable - 2);` |
| explicit operator IntPtr(long) | unchecked | will not throw when overflow | could throw in 32-bit contexts | `(IntPtr)longVariable;` |
| explicit operator void\*(IntPtr) | checked | throws when overflows | do not throw when overflow | `checked((void*)intPtrVariable);` |
| explicit operator IntPtr(void\*) | checked | throws when overflows | do not throw when overflow | `checked((IntPtr)voidPtrVariable);` |
| explicit operator int(IntPtr) | unchecked | will not throw when overflows | could throw in 64-bit contexts | `(int)intPtrVariable;` |
| operator +(UIntPtr, int) | checked | throws when overflows | do not throw when overflows | `checked(uintPtrVariable + 2);` |
| operator -(UIntPtr, int) | checked | throws when overflows | do not throw when overflows | `checked(uintPtrVariable - 2);` |
| explicit operator UIntPtr(ulong) | unchecked | will not throw when overflows | could throw in 32-bit contexts | `(UIntPtr)uLongVariable` |
| explicit operator uint(UIntPtr) | unchecked | will not throw when overflows | could throw in 64-bit contexts | `(uint)uintPtrVariable` |

## How to fix violations

Investigate the code to determine if the expression flagged could cause a behavioral change, and choose appropriate way to fix the diagnostic

Fix options:
 - If the expression would not cause a behavioral change:
   - If the `IntPtr/UIntPtr` type used as native int/uint purpose change the type to `nint/nuint`.
   - If the `IntPtr/UIntPtr` type used as native pointer change the type to corresponding native pointer type
   - If you cannot change the type of the variable last resort will be suppress the warning
 - If the expression could cause a behavioral change wrap it with corresponding `checked`/`unchecked` statement to preserve the .NET 6.0 behavior.

### Example

**Violation**:

```csharp
using System;

public unsafe class IntPtrTest
{
    IntPtr intPtrVariable;
    long longVariable;

    void Test ()
    {
        checked
        {
            IntPtr result = intPtrVariable + 2; // Warns: Starting with .NET 7 the operator '+' will throw when overflowing in a checked context. Wrap the expression with an 'unchecked' statement to restore the .NET 6 behavior.

            result = intPtrVariable - 2; // Starting with .NET 7 the operator '-' will throw when overflowing in a checked context. Wrap the expression with an 'unchecked' statement to restore the .NET 6 behavior.

            void* voidPtrVariable = (void*)intPtrVariable; // Starting with .NET 7 the explicit conversion '(void*)IntPtr' will throw when overflowing in a checked context. Wrap the expression with an 'unchecked' statement to restore the .NET 6 behavior.

            result = (IntPtr)voidPtrVariable; // Starting with .NET 7 the explicit conversion '(IntPtr)void*' will throw when overflowing in a checked context. Wrap the expression with an 'unchecked' statement to restore the .NET 6 behavior.
        }

        intPtrVariable = (IntPtr)longVariable; // Starting with .NET 7 the explicit conversion '(IntPtr)Int64' will not throw when overflowing in an unchecked context. Wrap the expression with a 'checked' statement to restore the .NET 6 behavior.

        int a = (int)intPtrVariable; // Starting with .NET 7 the explicit conversion '(Int32)IntPtr' will not throw when overflowing in an unchecked context. Wrap the expression with a 'checked' statement to restore the .NET 6 behavior.
	}
}
```

**Fix**:

- If the expression would not cause a behavioral change:
   - If the IntPtr/UIntPtr type used as native int/uint purpose change the type to nint/nuint.
   
  ```csharp
  using System;

  public unsafe class IntPtrTest
  {
      nint intPtrVariable; // type changed to nint
      long longVariable;

      void Test ()
      {
          checked
          {
              nint result = intPtrVariable + 2; // no warning

              result = intPtrVariable - 2;
 
              void* voidPtrVariable = (void*)intPtrVariable;

              result = (nint)voidPtrVariable;
          }

          intPtrVariable = (nint)longVariable; 

          int a = (int)intPtrVariable;
	  }
  }
```

 - If the expression could cause a behavioral change wrap it with corresponding `checked`/`unchecked` statement to preserve the old .NET 6.0 behavior.

  ```csharp
  using System;

  public unsafe class IntPtrTest
  {
      IntPtr intPtrVariable;
      long longVariable;

      void Test ()
      {
          checked
          {
              IntPtr result = unchecked(intPtrVariable + 2); // wrap with unchecked

              result = unchecked(intPtrVariable - 2);

              void* voidPtrVariable = unchecked((void*)intPtrVariable); 

              result = unchecked((IntPtr)voidPtrVariable); 
          }

          intPtrVariable = checked((IntPtr)longVariable); // wrap with checked

          int a = checked((int)intPtrVariable); //
	  }
  }
```

## When to suppress warnings

If the expression would not cause a behavioral change it is safe to suppress a warning from this rule.

## See also

- [Reliability rules](reliability-warnings.md)
- [numeric IntPtr feature](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/numeric-intptr.md)
