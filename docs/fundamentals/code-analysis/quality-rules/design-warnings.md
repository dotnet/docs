---
title: Design rules (code analysis)
description: "Learn about code analysis design rules."
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
---
# Design rules

Design rules support adherence to the [.NET Framework design guidelines](../../../standard/design-guidelines/index.md).

## In this section

| Rule | Description |
| - | - |
| [CA1000: Do not declare static members on generic types](ca1000.md) | When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused. |
| [CA1001: Types that own disposable fields should be disposable](ca1001.md) | A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface. |
| [CA1002: Do not expose generic lists](ca1002.md) | System.Collections.Generic.List<(Of \<(T>)>) is a generic collection that is designed for performance, not inheritance. Therefore, List does not contain any virtual members. The generic collections that are designed for inheritance should be exposed instead. |
| [CA1003: Use generic event handler instances](ca1003.md) | A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets .NET Framework 2.0. |
| [CA1005: Avoid excessive parameters on generic types](ca1005.md) | The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents. It is usually obvious with one type parameter, as in List\<T>, and in certain cases with two type parameters, as in Dictionary\<TKey, TValue>. However, if more than two type parameters exist, the difficulty becomes too great for most users. |
| [CA1008: Enums should have zero value](ca1008.md) | The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration. |
| [CA1010: Collections should implement generic interface](ca1010.md) | To broaden the usability of a collection, implement one of the generic collection interfaces. Then the collection can be used to populate generic collection types. |
| [CA1012: Abstract types should not have constructors](ca1012.md) | Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed. |
| [CA1014: Mark assemblies with CLSCompliantAttribute](ca1014.md) | The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute. If this attribute is not present on an assembly, the assembly is not compliant. |
| [CA1016: Mark assemblies with AssemblyVersionAttribute](ca1016.md) | .NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built. |
| [CA1017: Mark assemblies with ComVisibleAttribute](ca1017.md) | ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients. |
| [CA1018: Mark attributes with AttributeUsageAttribute](ca1018.md) | When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied. The meaning and intended usage of an attribute will determine its valid locations in code. |
| [CA1019: Define accessors for attribute arguments](ca1019.md) | Attributes can define mandatory arguments that must be specified when you apply the attribute to a target. These are also known as positional arguments because they are supplied to attribute constructors as positional parameters. For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time. Attributes can also define optional arguments, which are also known as named arguments. These arguments are supplied to attribute constructors by name and should have a corresponding read/write property. |
| [CA1021: Avoid out parameters](ca1021.md) | Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Also, the difference between out and ref parameters is not widely understood. |
| [CA1024: Use properties where appropriate](ca1024.md) | A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property. |
| [CA1027: Mark enums with FlagsAttribute](ca1027.md) | An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined. |
| [CA1028: Enum storage should be Int32](ca1028.md) | An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Even though you can change this underlying type, it is not required or recommended for most scenarios. |
| [CA1030: Use events where appropriate](ca1030.md) | This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly. |
| [CA1031: Do not catch general exception types](ca1031.md) | General exceptions should not be caught. Catch a more-specific exception, or rethrow the general exception as the last statement in the catch block. |
| [CA1032: Implement standard exception constructors](ca1032.md) | Failure to provide the full set of constructors can make it difficult to correctly handle exceptions. |
| [CA1033: Interface methods should be callable by child types](ca1033.md) | An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name. |
| [CA1034: Nested types should not be visible](ca1034.md) | A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible. |
| [CA1036: Override methods on comparable types](ca1036.md) | A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than. |
| [CA1040: Avoid empty interfaces](ca1040.md) | Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented. |
| [CA1041: Provide ObsoleteAttribute message](ca1041.md) | A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed, which gives the user information about the obsolete type or member. |
| [CA1043: Use integral or string argument for indexers](ca1043.md) | Indexers (that is, indexed properties) should use integral or string types for the index. These types are typically used for indexing data structures and they increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time. |
| [CA1044: Properties should not be write only](ca1044.md) | Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness. |
| [CA1045: Do not pass types by reference](ca1045.md) | Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Library architects who design for a general audience should not expect users to become proficient in working with out or ref parameters. |
| [CA1046: Do not overload operator equals on reference types](ca1046.md) | For reference types, the default implementation of the equality operator is almost always correct. By default, two references are equal only if they point to the same object. |
| [CA1047: Do not declare protected members in sealed types](ca1047.md) | Types declare protected members so that inheriting types can access or override the member. By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called. |
| [CA1050: Declare types in namespaces](ca1050.md) | Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy. |
| [CA1051: Do not declare visible instance fields](ca1051.md) | The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties. |
| [CA1052: Static holder types should be sealed](ca1052.md) | A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic) modifier. A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type. |
| [CA1053: Static holder types should not have constructors](ca1053.md) | A public or nested public type declares only static members and has a public or protected default constructor. The constructor is unnecessary because calling static members does not require an instance of the type. The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security. |
| [CA1054: URI parameters should not be strings](ca1054.md) | If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner. |
| [CA1055: URI return values should not be strings](ca1055.md) | This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner. |
| [CA1056: URI properties should not be strings](ca1056.md) | This rule assumes that the property represents a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner. |
| [CA1058: Types should not extend certain base types](ca1058.md) | An externally visible type extends certain base types. Use one of the alternatives. |
| [CA1060: Move P/Invokes to NativeMethods class](ca1060.md) | Platform Invocation methods, such as those marked with the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> or methods defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class. |
| [CA1061: Do not hide base class methods](ca1061.md) | A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method. |
| [CA1062: Validate arguments of public methods](ca1062.md) | All reference arguments that are passed to externally visible methods should be checked against null. |
| [CA1063: Implement IDisposable correctly](ca1063.md) | All IDisposable types should implement the Dispose pattern correctly. |
| [CA1064: Exceptions should be public](ca1064.md) | An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName>, or <xref:System.ApplicationException?displayProperty=fullName>, the external code will not have sufficient information to know what to do with the exception. |
| [CA1065: Do not raise exceptions in unexpected locations](ca1065.md) | A method that is not expected to throw exceptions throws an exception. |
| [CA1066: Implement IEquatable when overriding Equals](ca1066.md) | A value type overrides <xref:System.Object.Equals%2A> method, but does not implement <xref:System.IEquatable%601>. |
| [CA1067: Override Equals when implementing IEquatable](ca1067.md) | A type implements <xref:System.IEquatable%601>, but does not override <xref:System.Object.Equals%2A> method. |
| [CA1068: CancellationToken parameters must come last](ca1068.md) | A method has a CancellationToken parameter that is not the last parameter. |
| [CA1069: Enums should not have duplicate values](ca1069.md) | An enumeration has multiple members which are explicitly assigned the same constant value. |
| [CA1070: Do not declare event fields as virtual](ca1070.md) | A [field-like event](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) was declared as virtual. |
