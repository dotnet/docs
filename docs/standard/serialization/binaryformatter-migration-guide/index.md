---
title: "BinaryFormatter Migration Guide"
description: "This guide covers the deprecation and removal of BinaryFormatter from .NET and recommends migration paths."
ms.date: 5/31/2024
no-loc: [BinaryFormatter, Serialization]
helpviewer_keywords:
  - "BinaryFormatter"
  - "serializing objects"
  - "serialization"
  - "objects, serializing"
---

# BinaryFormatter migration guide

Ever since .NET Core 1.0, the .NET security team has been trying to lay BinaryFormatter to rest. It's long been known by security practitioners that any deserializer, binary or text, that allows its input to carry information about the objects to be created is a security problem waiting to happen. There is even a common weakness enumeration (CWE) that describes the issue: [CWE-502 “Deserialization of Untrusted Data”](https://cwe.mitre.org/data/definitions/502.html). Examples of this type of vulnerability run from security issues in Microsoft Exchange Server through security issues in Apache. Within Microsoft, the use of BinaryFormatter with untrusted input has caused many instances of heartache, late nights, and weekend work trying to produce a solution.

BinaryFormatter was removed entirely in .NET Core 1.0 due to its known risks, but without a clear path to using something safer, customer demand brought it back in .NET Core 1.1. Since then, the .NET team has been on the path to removing BinaryFormatter, slowly turning it off by default in multiple project types but letting consumers opt-in via flags if still needed for backward compatibility. .NET 9 sees the culmination of this effort with the removal of BinaryFormatter. In .NET 9, the backwards compatibility flags no longer exist and the in-box implementation of BinaryFormatter throws exceptions in any project type when you try to use it. However, if you're committed to using a class that cannot be made secure, you are still able to by using the [Compatibility Package](./compatibility-package.md).

For more details about the decision, see the [BinaryFormatter is being removed in .NET 9](https://github.com/dotnet/announcements/issues/293) announcement. If you want to share feedback, leave a comment in [the discussion issue](https://github.com/dotnet/runtime/issues/98245).

## Migration topics

Migrating from `BinaryFormatter` has to start with [choosing a different serializer](./choosing-a-serializer.md).

The next questions that need to be answered are:

- Was the data persisted anywhere? If so, is it possible to stop all the live services that consume the persisted data and migrate all of it at once?
- Are there any public APIs that accept NRBF (.NET Remoting Binary Format) data? If so, can all the consumers provide the input in a different format?

Depending on the answers, it might be required to [read NRBF payloads](./reading-nrbf-payloads.md) created with `BinaryFormatter`. In such case, see the [BinaryFormatter functionality reference](./functionality-reference.md) to have a good understanding of how it works, so the process of migration can be less painful.

Moreover, Windows Forms and WPF apps might require some additional changes starting from .NET 9 Preview 7.

## Summary

* `BinaryFormatter` by default serializes **all fields** that are not marked with `[NonSerialized]` attribute. For auto-properties, it uses names generated by the compiler. It can be customized by implementing  `GetObjectData` method from `ISerializable` interface as well as a deserialization constructor that accepts `SerializationInfo info` and `StreamingContext context` arguments. It also preserves references and handles circular references.
* Is compact binary representation important for your scenario? If so, you need to switch to a different binary serializer. If not, you can consider using XML and JSON serializers.
* [DataContractSerializer](../../../fundamentals/runtime-libraries/system-runtime-serialization-datacontractserializer.md) is an XML serializer that **fully supports the serialization programming model that was used by the `BinaryFormatter`**. It requires the known types to be specified up-front (but most .NET collections and primitive types are on a default allow-list and don't need to be specified). It's the serializer that requires the least amount of effort to migrate to.
* [System.Text.Json](./../system-text-json/overview.md) is strict by default and avoids any guessing or interpretation on the caller's behalf, emphasizing deterministic behavior. The library is intentionally designed this way for performance and security. In contrary to `BinaryFormatter`, by default it serializes **only public properties**. To deserialize a `readonly` field or property, `[JsonConstructor]` attribute needs be used to indicate that given constructor should be used to set these. It supports serialization and deserialization of most built-in collections, but it does not support dictionaries where keys are not primitive types. It supports polymorphic type hierarchy serialization and deserialization, but it needs to be explicitly enabled. The same goes for preserving the references and handling circular references. The default behavior can be changed by writing custom converters.
* [MessagePack](https://github.com/MessagePack-CSharp/MessagePack-CSharp) provides a highly efficient binary serialization format, resulting in smaller message sizes compared to JSON and XML. It's performant and ships with built-in support for LZ4 compression. It works best when all serializable public types and members are annotated with dedicated attributes. It does not serialize non-public types and members by default, but it can be customized. It supports read-only types and members by trying to select the best matching constructor. The constructor can be specified explicitly by using the `[SerializationConstructor]` attribute.
* `NrbfDecoder` can be used for reading any `BinaryFormatter` payload that was either persisted before the migration or comes from an actor that can not be migrated (such as a client app owned by a third party). This new type can read any NRBF (.NET Remoting Binary Format) payload, but it's mandatory to know the list of types that could have been serialized. Otherwise, it's impossible to create and hydrate the serialized objects.
* It's **unsafe and not recommended, but still possible** to keep using `BinaryFormatter` in .NET 9+ apps. It requires installing the [System.Runtime.Serialization.Formatters](https://www.nuget.org/packages/System.Runtime.Serialization.Formatters) NuGet package and setting the `System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization` AppContext switch to `true`.
