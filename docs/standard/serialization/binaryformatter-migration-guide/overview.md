---
title: "BinaryFormatter Migration Guide"
description: "This guide covers the deprecation and removal of BinaryFormatter from .NET and recommends migration paths."
ms.date: 5/31/2024
no-loc: [BinaryFormatter, Serialization]
dev_langs:
  - CSharp
  - VB
helpviewer_keywords:
  - "BinaryFormatter"
  - "serializing objects"
  - "serialization"
  - "objects, serializing"
---

# BinaryFormatter migration guide

Ever since .NET Core 1.0, we in .NET Security have been trying to lay BinaryFormatter to rest. It's long been known by security practitioners that any deserializer, binary or text, which allows its input to carry information about the objects to be created is a security problem waiting to happen. There is even a Common Weakness Enumeration (CWE) that describes the issue, [CWE-502 “Deserialization of Untrusted Data”](https://cwe.mitre.org/data/definitions/502.html) and examples of this type of vulnerability run from security issues in Exchange through security issues in Apache. Within Microsoft the use of BinaryFormatter with untrusted input has caused many instances of heartache, late nights, and weekend work trying to produce a solution.

In .NET Core 1.0 we removed BinaryFormatter entirely due to its known risks, but without a clear path to using something safer customer demand brought it back to .NET Core 1.1. Since then, we have been on the path to removal, slowly turning it off by default in multiple project types but letting you opt-in via flags if you still needed it for backward compatibility. .NET 9 sees the culmination of this effort with the removal of BinaryFormatter. In .NET 9 these flags will no longer exist and the in-box implementation of BinaryFormatter will throw exceptions in any project type when you try to use it. However, if you are committed to using a class that cannot be made secure you will still be able to by using the [Compatibility Package](./compatibility-package.md).

If you want to find out more details about our decision please read [BinaryFormatter is being removed in .NET 9](https://github.com/dotnet/announcements/issues/293) announcement. If you want to share some feedback, please leave a comment in [the discussion issue](https://github.com/dotnet/runtime/issues/98245).

## Migration topics

Migrating from `BinaryFormatter` has to start with [choosing a different serializer](./choosing-a-serializer.md).

The next questions that need to be answered are:

- Was the data persisted anywhere? If so, is it possible to stop all the live services that consume the persisted data and migrate all of it at once?
- Are there any public APIs that accept NRBF (.NET Remoting Binary Format) data? If so, can all the consumers provide the input in a different format?

Depending on the answers, it may be required to [read NRBF payloads](./reading-nrbf-payloads.md) created with `BinaryFormatter`. In such case, it's recommended to read the [BinaryFormatter functionality reference](./functionality-reference.md) to have a good understanding of it works, so the process of migration can be less painful.

Moreover, WinForms and WPF may require some additional changes starting from .NET 9 Preview 7.

## Summary

* `BinaryFormatter` by default serializes **all fields** that are not marked with `[NonSerialized]` attribute. For auto-properties, it uses names generated by the compiler. It can be customized by implementing  `GetObjectData` method from `ISerializable` interface as well as a deserialization constructor that accepts `SerializationInfo info` and `StreamingContext context` arguments. It also preserves references and handles circular references.
* Is compact binary representation important for your scenario? If so, you need to switch to a different binary serializer. If not, you can consider using XML and JSON serializers.
* [DataContractSerializer](../../../fundamentals/runtime-libraries/system-runtime-serialization-datacontractserializer.md) is an XML serializer that **fully supports the serialization programming model that was used by the `BinaryFormatter`**. It requires the known types to be specified up-front (but most .NET collections and primitive types are on a default allow-list and don't need to be specified). **It's the serializer that requires the least amount of effort to migrate to**.
* [System.Text.Json](./../system-text-json/overview.md) is strict by default and avoids any guessing or interpretation on the caller's behalf, emphasizing deterministic behavior. The library is intentionally designed this way for performance and security. In contrary to `BinaryFormatter`, by default it serializes **only public properties**. To deserialize a `readonly` field or property, `[JsonConstructor]` attribute needs be used to indicate that given constructor should be used to set these. It supports serialization and deserialization of most built-in collections, but it does not support dictionaries where keys are not primitive types. It supports polymorphic type hierarchy serialization and deserialization, but it needs to be explicitly enabled. The same goes for preserving the references and handling circular references. The default behavior can be changed by writing custom converters.
* [MessagePack](https://github.com/MessagePack-CSharp/MessagePack-CSharp) provides a **highly efficient binary serialization format**, resulting in smaller message sizes compared to JSON and XML. It's **very performant** and ships with built-in support for LZ4 compression. It works best when all serializable public types and members are annotated with dedicated attributes. It does not serialize non-public types and members by default, but it can be customized. It supports readonly types and members, by trying to select the best matching constructor. The constructor can be selected in an explicit way by using the `[SerializationConstructor]` attribute.
* `NrbfDecoder` can be used for reading any `BinaryFormatter` payload that was either persisted before the migration or comes from an actor that can not be migrated (such as a client app owned by a 3rd party). This new type can read any NRBF (.NET Remoting Binary Format) payload, but it's mandatory to know the list of types that could have been serialized. Otherwise, it's impossible to create and hydrate the serialized objects.
* It's **unsafe and not recommended, but still possible** to keep using `BinaryFormatter` in .NET 9+ apps. It requires installing the [System.Runtime.Serialization.Formatters](https://www.nuget.org/packages/System.Runtime.Serialization.Formatters) NuGet package and setting the `System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization` AppContext switch to `true`.
