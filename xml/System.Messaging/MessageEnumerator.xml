<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Provides a forward-only cursor to enumerate through messages in a message queue.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageEnumerator> for dynamic interaction with messages in a queue. Methods available through the <xref:System.Messaging.MessageQueue> class can return either a <xref:System.Messaging.MessageEnumerator> pointing to a dynamic list of messages in the queue, or an array that contains a copy at a given instant - a snapshot - of the queue at the time the specified method was called.  
  
 Unlike a static snapshot, an enumerator allows you to modify the collection. Using a <xref:System.Messaging.MessageEnumerator>, you can remove messages from the queue, and the change is immediately reflected in the queue.  
  
 An enumerator does not remove the messages from the queue when it queries the queue. It returns information about the message at the current cursor position, but it leaves the message in the queue.  
  
 A <xref:System.Messaging.MessageEnumerator> is a cursor, initialized to the head of a dynamic list. The list order is the same as the order of the messages in the queue, according to message priority. You can move the cursor to the first message in the queue by calling <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. After the enumerator has been initialized, you can use <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to step forward through the remaining messages. You can specify whether to wait for a message to become available by passing a timeout into the <xref:System.Messaging.MessageEnumerator.MoveNext%2A> method.  
  
 Because the enumerator is dynamic, a message that is appended beyond the cursor's current position (for example, due to low priority), can be accessed by the enumerator. A message that is inserted before the cursor's current position cannot be accessed. It is not possible to step backward with a <xref:System.Messaging.MessageEnumerator>. A cursor allows forward-only movement. The <xref:System.Messaging.MessageEnumerator.Reset%2A> method enables you to place the cursor back at the beginning of the queue.  
  
 Instances of <xref:System.Messaging.MessageEnumerator> for a given queue work independently. You can create two <xref:System.Messaging.MessageEnumerator> instances that apply to the same queue. The changes that one <xref:System.Messaging.MessageEnumerator> makes to the messages in the queue will be reflected immediately in a second enumerator if the second enumerator is positioned before the first. However, if two enumerators have the same position and one of them removes the message at that position, an exception is thrown if the other enumerator attempts to get the value of the <xref:System.Messaging.MessageEnumerator.Current%2A> property on the now-deleted message.  
  
> [!NOTE]
>  If you create an instance of <xref:System.Messaging.MessageQueue> with <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> set to `true`, no other application can modify the messages in your enumerator while you have the connection to the queue.  
  
   
  
## Examples  
 The following example gets a dynamic list of messages in a queue and counts all messages with the <xref:System.Messaging.Message.Priority%2A> property set to <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Frees the resources associated with the enumerator.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The operating system retains an open handle to the queue during the lifetime of the cursor. When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release the resources associated with the handle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current <see cref="T:System.Messaging.Message" /> that this enumerator points to.</summary>
        <value>The current message.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When the enumerator is created, it points to the head of the queue, at a location before the first message. In this case, <xref:System.Messaging.MessageEnumerator.Current%2A> is not valid and will throw an exception if it is accessed. You must call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to position the cursor at the first message in the queue.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> before the first call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. The cursor is located before the first element of the message enumeration.  
  
 -or-  
  
 You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> after a call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> had returned <see langword="false" /> (indicating the cursor is located after the last element of the message enumeration.)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The message the enumerator is currently pointing to no longer exists. It might have been deleted.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native Message Queuing cursor handle used to browse messages in the queue.</summary>
        <value>The native cursor handle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This property contains the native handle to the enumeration. When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release this resource.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">The handle does not exist.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Releases the resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Calling <xref:System.Messaging.MessageEnumerator.Dispose%2A> allows the resources used by the <xref:System.Messaging.MessageEnumerator> to be reallocated for other purposes. For more information about <xref:System.Messaging.MessageEnumerator.Dispose%2A>, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Cleaning Up Unmanaged Resources</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.Messaging.MessageEnumerator" /> and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is called by the public <xref:System.Messaging.MessageEnumerator.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method. `Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`. <xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.  
  
 When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Messaging.MessageEnumerator> references. This method invokes the `Dispose()` method of each referenced object.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> can be called multiple times by other objects. When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />. For more information about how to implement <see langword="Dispose" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 For more information about <see langword="Dispose" /> and <see langword="Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementing a Dispose method</related>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Cleaning Up Unmanaged Resources</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the resources held by the enumerator.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
This method overrides <xref:System.Object.Finalize>. Application code should not call this method; an object's Finalize method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.

For more information, see [Finalize Methods and Destructors](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100)), [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md), and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Advances the enumerator to the next message in the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Advances the enumerator to the next message in the queue, if one is currently available.</summary>
        <returns>
          <see langword="true" /> if the enumerator was succesfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This overload returns immediately if there is no message in the queue. There is another overload that waits a specified <xref:System.TimeSpan> for a message to arrive.  
  
 If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> returns `false` to the calling method.  
  
 Upon creation, an enumerator is conceptually positioned before the first message of the queue, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the queue into view.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An exception specific to Message Queuing was thrown.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">The <see cref="T:System.TimeSpan" /> to wait for a message to be available if the enumerator is positioned at the end of the queue.</param>
        <summary>Advances the enumerator to the next message in the queue. If the enumerator is positioned at the end of the queue, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> waits until a message is available or the given timeout expires.</summary>
        <returns>
          <see langword="true" /> if the enumerator successfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue and a message does not become available within the time specified by the <paramref name="timeout" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This overload waits if there is no message in the queue or if the cursor has reached the end of the queue. If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> waits the specified timeout.  
  
 If the cursor is already at the end of the queue, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> only returns `true` if the new message arrives within the specified time interval, has lower priority than all messages currently in the queue and is placed at the end of the queue. An overload with no parameter returns immediately if no further messages are in the queue.  
  
 Upon creation, an enumerator is conceptually positioned before the first message of the enumeration, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the enumeration into view.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the timeout parameter is invalid. It might represent a negative number.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An exception specific to Message Queuing was thrown.  
  
 -or-  
  
 The timeout has expired.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Removes the current message from the queue and returns the message to the calling application. Removing the message deletes it from the queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The behavior described for these overloads is applicable only if the <xref:System.Messaging.MessageEnumerator> instance is retrieved by using the <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>. Do not use <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> to retrieve an instance of <xref:System.Messaging.MessageEnumerator> as this method has been deprecated.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes the current message from a transactional or non-transactional queue and returns the message to the calling application. There is no timeout specified for a message to arrive in the queue.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.  
  
 If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.  
  
 When you remove the current message, the cursor is moved to the next message. You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction in which the message will be removed.</param>
        <summary>Removes the current message from a transactional queue and returns the message to the calling application. There is no timeout specified for a message to arrive in the queue.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using the internal transaction context defined by the `transaction` parameter.  
  
 If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.  
  
 When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue. The removal is not irreversible until the transaction is committed.  
  
 When you remove the current message, the cursor is moved to the next message. You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Removes the current message from a queue and returns the message to the calling application. There is no timeout specified for a message to arrive in the queue.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.  
  
 Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message. Specify `Single` if you want to receive the message as a single internal transaction. You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.  
  
 If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.  
  
 When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue. The removal is not irreversible until the transaction is committed.  
  
 When you remove the current message, the cursor is moved to the next message. You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">The interval of time to wait for a message to arrive in the queue.</param>
        <summary>Removes the current message from the queue and returns the message to the calling application. If there is a message to remove, the method returns it immediately. Otherwise, the method waits the specified timeout for a new message to arrive.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location. If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.  
  
 If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.  
  
 When you remove the current message, the cursor is moved to the next message. You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is invalid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The timeout has expired.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">The interval of time to wait for the message to be removed.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction context for the message.</param>
        <summary>Removes the current message from a transactional queue and returns the message to the calling application. If there is a message to remove, the method returns it immediately. Otherwise, the method waits the specified timeout for a new message to arrive.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location. If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.  
  
 When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue. The removal is not irreversible until the transaction is committed.  
  
 If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.  
  
 When you remove the current message, the cursor is moved to the next message. You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is invalid.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The timeout has expired.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">The interval of time to wait for the message to be removed.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Removes the current message from a queue and returns the message to the calling application. If there is a message to remove, the method returns it immediately. Otherwise, the method waits the specified timeout for a new message to arrive.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter. If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.  
  
 Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message. Specify `Single` if you want to receive the message as a single internal transaction. You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.  
  
 If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.  
  
 When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue. The removal is not irreversible until the transaction is committed.  
  
 When you remove the current message, the cursor is moved to the next message. You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is invalid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The timeout has expired.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the current enumerator so it points to the head of the queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 An enumerator can only move in a forward direction. Use this method to start over at the beginning of the queue.  
  
 After calling <xref:System.Messaging.MessageEnumerator.Reset%2A>, the cursor points to the first message. You do not need to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.Reset%2A> to move the cursor forward to the first message in the queue.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</summary>
        <value>A <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>