<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides access to a queue on a Message Queuing server.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The Message Queuing technology allows applications running at different times to communicate across heterogeneous networks and systems that might be temporarily offline. Applications send, receive, or peek (read without removing) messages from queues. Message Queuing is an optional component of [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] and Windows NT, and must be installed separately.  
  
 The <xref:System.Messaging.MessageQueue> class is a wrapper around Message Queuing. There are multiple versions of Message Queuing, and using the <xref:System.Messaging.MessageQueue> class can result in slightly different behavior, depending on the operating system you are using. For information about specific features of each version of Message Queuing, see the topic "What's New in Message Queuing" in the Platform SDK in MSDN.  
  
 The <xref:System.Messaging.MessageQueue> class provides a reference to a Message Queuing queue. You can specify a path in the <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor to connect to an existing resource, or you can create a new queue on the server. Before you can call <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, or <xref:System.Messaging.MessageQueue.Receive%2A>, you must associate the new instance of the <xref:System.Messaging.MessageQueue> class with an existing queue. At that point, you can manipulate the queue properties such as <xref:System.Messaging.MessageQueue.Category%2A> and <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> supports two types of message retrieval: synchronous and asynchronous. The synchronous methods, <xref:System.Messaging.MessageQueue.Peek%2A> and <xref:System.Messaging.MessageQueue.Receive%2A>, cause the process thread to wait a specified time interval for a new message to arrive in the queue. The asynchronous methods, <xref:System.Messaging.MessageQueue.BeginPeek%2A> and <xref:System.Messaging.MessageQueue.BeginReceive%2A>, allow the main application tasks to continue in a separate thread until a message arrives in the queue. These methods work by using callback objects and state objects to communicate information between threads.  
  
 When you create a new instance of the <xref:System.Messaging.MessageQueue> class, you are not creating a new Message Queuing queue. Instead, you can use the <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, and <xref:System.Messaging.MessageQueue.Purge%2A> methods to manage queues on the server.  
  
 Unlike <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> and <xref:System.Messaging.MessageQueue.Delete%28System.String%29> are `static` members, so you can call them without creating a new instance of the <xref:System.Messaging.MessageQueue> class.  
  
 You can set the <xref:System.Messaging.MessageQueue> object's <xref:System.Messaging.MessageQueue.Path%2A> property with one of three names: the friendly name, the <xref:System.Messaging.MessageQueue.FormatName%2A>, or the <xref:System.Messaging.MessageQueue.Label%2A>. The friendly name, which is defined by the queue's <xref:System.Messaging.MessageQueue.MachineName%2A> and <xref:System.Messaging.MessageQueue.QueueName%2A> properties, is <xref:System.Messaging.MessageQueue.MachineName%2A>\\<xref:System.Messaging.MessageQueue.QueueName%2A> for a public queue, and <xref:System.Messaging.MessageQueue.MachineName%2A>\\`Private$`\\<xref:System.Messaging.MessageQueue.QueueName%2A> for a private queue. The <xref:System.Messaging.MessageQueue.FormatName%2A> property allows offline access to message queues. Lastly, you can use the queue's <xref:System.Messaging.MessageQueue.Label%2A> property to set the queue's <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 For a list of initial property values for an instance of <xref:System.Messaging.MessageQueue>, see the <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor.  
  
   
  
## Examples  
 The following code example creates new <xref:System.Messaging.MessageQueue> objects using various path name syntax types. In each case, it sends a message to the queue whose path is defined in the constructor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 The following code example sends a message to a queue, and receives a message from a queue, using an application-specific class called `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Only the <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> method is thread safe.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class. After the default constructor initializes the new instance, you must set the instance's <see cref="P:System.Messaging.MessageQueue.Path" /> property before you can use the instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to create a new instance of the <xref:System.Messaging.MessageQueue> class that is not immediately tied to a queue on the Message Queuing server. Before using this instance, you must connect it to an existing Message Queuing queue by setting the <xref:System.Messaging.MessageQueue.Path%2A> property. Alternatively, you can set the <xref:System.Messaging.MessageQueue> reference to the <xref:System.Messaging.MessageQueue.Create%28System.String%29> method's return value, thereby creating a new Message Queuing queue.  
  
 The <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor instantiates a new instance of the <xref:System.Messaging.MessageQueue> class; it does not create a new Message Queuing queue.  
  
 The following table shows initial property values for an instance of <xref:System.Messaging.MessageQueue>.  
  
|Property|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|The values set by the default constructor of the <xref:System.Messaging.DefaultPropertiesToSend> class.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|The values set by the default constructor of the <xref:System.Messaging.MessagePropertyFilter> class. All the filter values are set to `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 The following code example creates a new <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class that references the Message Queuing queue at the specified path.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload when you want to tie the new <xref:System.Messaging.MessageQueue> instance to a particular Message Queuing queue, for which you know the path, format name, or label. If you want to grant exclusive access to the first application that references the queue, you must set the <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> property to `true` or use the constructor that passes a read-access restriction parameter.  
  
 The <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor instantiates a new instance of the <xref:System.Messaging.MessageQueue> class; it does not create a new Message Queuing queue. To create a new queue in Message Queuing, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 The syntax of the `path` parameter depends on the type of queue it references, as shown in the following table.  
  
|Queue type|Syntax|  
|----------------|------------|  
|Public queue|`MachineName`\\`QueueName`|  
|Private queue|`MachineName`\\`Private$`\\`QueueName`|  
|Journal queue|`MachineName`\\`QueueName`\\`Journal$`|  
|Machine journal queue|`MachineName`\\`Journal$`|  
|Machine dead-letter queue|`MachineName`\\`Deadletter$`|  
|Machine transactional dead-letter queue|`MachineName`\\`XactDeadletter$`|  
  
 Alternatively, you can use the <xref:System.Messaging.MessageQueue.FormatName%2A> or <xref:System.Messaging.MessageQueue.Label%2A> to describe the queue path, as shown in the following table.  
  
|Reference|Syntax|Example|  
|---------------|------------|-------------|  
|Format name|`FormatName:` [ *format name* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Label|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 To work offline, you must use the format name syntax, not the path name syntax for the constructor. Otherwise, an exception is thrown because the primary domain controller is not available to resolve the path to the format name.  
  
 The following table shows initial property values for an instance of <xref:System.Messaging.MessageQueue>. These values are based on the properties of the Message Queuing queue with the path specified by the `path` parameter.  
  
|Property|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|The values set by the default constructor of the <xref:System.Messaging.DefaultPropertiesToSend> class.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, if the Message Queuing queue's privacy level setting is "Body"; otherwise, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|The value of the Message Queuing queue's computer name property.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|The values set by the default constructor of the <xref:System.Messaging.MessagePropertyFilter> class.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, if not set by the constructor.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, if not set by the constructor.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, if the Message Queuing object's journal setting is enabled; otherwise, `false`.|  
  
   
  
## Examples  
 The following code example creates new <xref:System.Messaging.MessageQueue> objects using various path name syntax types. In each case, it sends a message to the queue whose path is defined in the constructor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property is not valid, possibly because it has not been set.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class that references the Message Queuing queue at the specified path and with the specified read-access restriction.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload when you want to tie the new <xref:System.Messaging.MessageQueue> to a particular Message Queuing queue, for which you know the path, format name, or label. If you want to grant exclusive access to the first application that references the queue, set the `sharedModeDenyReceive` parameter to `true`. Otherwise, set `sharedModeDenyReceive` to `false` or use the constructor that has only a `path` parameter.  
  
 Setting `sharedModeDenyReceive` to `true` affects all objects that access the Message Queuing queue, including other applications. The effects of the parameter are not restricted to this application.  
  
 The <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor creates a new instance of the <xref:System.Messaging.MessageQueue> class; it does not create a new Message Queuing queue. To create a new queue in Message Queuing, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 The syntax of the `path` parameter depends on the type of queue.  
  
|Queue type|Syntax|  
|----------------|------------|  
|Public queue|`MachineName`\\`QueueName`|  
|Private queue|`MachineName`\\`Private$`\\`QueueName`|  
|Journal queue|`MachineName`\\`QueueName`\\`Journal$`|  
|Machine journal queue|`MachineName`\\`Journal$`|  
|Machine dead-letter queue|`MachineName`\\`Deadletter$`|  
|Machine transactional dead-letter queue|`MachineName`\\`XactDeadletter$`|  
  
 Alternatively, you can use the format name or label of a Message Queuing queue to describe the queue path.  
  
|Reference|Syntax|Example|  
|---------------|------------|-------------|  
|Format name|`FormatName:` [ *format name* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Label|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 To work offline, you must use the format name syntax, rather than the friendly name syntax. Otherwise, an exception is thrown because the primary domain controller (on which Active Directory resides) is not available to resolve the path to the format name.  
  
 If a <xref:System.Messaging.MessageQueue> opens a queue with the `sharedModeDenyReceive` parameter set to `true`, any <xref:System.Messaging.MessageQueue> that subsequently tries to read from the queue generates a <xref:System.Messaging.MessageQueueException> because of a sharing violation. A <xref:System.Messaging.MessageQueueException> is also thrown if a <xref:System.Messaging.MessageQueue> tries to access the queue in exclusive mode while another <xref:System.Messaging.MessageQueue> already has non-exclusive access to the queue.  
  
 The following table shows initial property values for an instance of <xref:System.Messaging.MessageQueue>. These values are based on the properties of the Message Queuing queue, with the path specified by the `path` parameter.  
  
|Property|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|The values set by the default constructor of the <xref:System.Messaging.DefaultPropertiesToSend> class.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, if the Message Queuing queue's privacy level setting is "Body"; otherwise, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|The value of the Message Queuing queue's computer name property.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|The values set by the default constructor of the <xref:System.Messaging.MessagePropertyFilter> class.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, if not set by the constructor.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, if not set by the constructor.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|The value of the `sharedModeDenyReceive` parameter.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, if the Message Queuing object's journal setting is enabled; otherwise, `false`.|  
  
   
  
## Examples  
 The following code example creates a new <xref:System.Messaging.MessageQueue> with exclusive access, sets its path, and sends a message to the queue.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property is not valid, possibly because it has not been set.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</param>
        <param name="accessMode">One of the <see cref="T:System.Messaging.QueueAccessMode" /> values.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> to create and use a connection cache; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following code example creates a new <xref:System.Messaging.MessageQueue> with exclusive read access and with connection caching enabled.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> to create and use a connection cache; otherwise, <see langword="false" />.</param>
        <param name="accessMode">One of the <see cref="T:System.Messaging.QueueAccessMode" /> values.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates the access mode for the queue.</summary>
        <value>One of the <see cref="T:System.Messaging.QueueAccessMode" /> values.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The default access mode for a queue is `QueueAccessMode.SendAndReceive`, unless you specify otherwise when calling the constructor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the queue accepts only authenticated messages.</summary>
        <value>
          <see langword="true" /> if the queue accepts only authenticated messages; otherwise, <see langword="false" />. The default is <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message authentication provides a way to ensure message integrity and to verify who sent the message. To request authentication, the sending application sets the message's authentication level.  
  
 When you set <xref:System.Messaging.MessageQueue.Authenticate%2A> to `true`, you are restricting access to the queue on the server, not only to this <xref:System.Messaging.MessageQueue> instance. All clients working against the same Message Queuing queue will be affected.  
  
 A queue that accepts only authenticated messages will reject a non-authenticated message. To request notification of message rejection, a sending application can set the <xref:System.Messaging.Message.AcknowledgeType%2A> property of the message. Because no other indication of message rejection exists, the sending application can lose the message unless you request that it be sent to the dead-letter queue.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.Authenticate%2A> property.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the base priority Message Queuing uses to route a public queue's messages over the network.</summary>
        <value>The single base priority for all messages sent to the (public) queue. The default is zero (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A message queue's base priority specifies how a message en route to that queue is treated as it travels through the network. You can set the <xref:System.Messaging.MessageQueue.BasePriority%2A> property to confer a higher or lower priority to all messages sent to the specified queue than those sent to other queues. Setting this property modifies the Message Queuing queue. Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change.  
  
 A message queue's <xref:System.Messaging.MessageQueue.BasePriority%2A> is not related to the <xref:System.Messaging.Message.Priority%2A> property of a message, which specifies the order in which an incoming message is placed in the queue.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> applies only to public queues whose paths are specified using the format name. The base priority of a private queue is always zero (0).  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.BasePriority%2A> property.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The base priority was set to an invalid value.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>The method is not thread safe.</threadsafe>
        <summary>Initiates an asynchronous peek operation by telling Message Queuing to begin peeking a message and notify the event handler when finished.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiates an asynchronous peek operation that has no time-out. The operation is not complete until a message becomes available in the queue.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginPeek%2A> to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message becomes available in the queue.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.  
  
 To use <xref:System.Messaging.MessageQueue.BeginPeek%2A>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiates an asynchronous peek operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.PeekCompleted> event, when a message arrives in the queue. The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> or by retrieving the result using the <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  
  
 Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution. To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.  
  
 Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  
  
 The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  
  
 If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example creates an event handler named `MyPeekCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> to initiate an asynchronous peek operation on the queue that is located at the path ".\myQueue". When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the example peeks the message and writes its body to the screen. The example then calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> again to initiate a new asynchronous peek operation.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <summary>Initiates an asynchronous peek operation that has a specified time-out. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginPeek%2A> to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.  
  
 To use <xref:System.Messaging.MessageQueue.BeginPeek%2A>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiates an asynchronous peek operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.PeekCompleted> event, when a message arrives in the queue. The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> or by retrieving the result using the <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  
  
 Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution. To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.  
  
 Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  
  
 The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  
  
 This overload specifies a time-out. If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.PeekCompleted> event. Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> will throw an exception.  
  
 If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example creates an asynchronous peek operation, using the queue path ".\myQueue". It creates an event handler, `MyPeekCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate. <xref:System.Messaging.MessageQueue.BeginPeek%2A> is called with a time-out of one minute, to initiate the asynchronous peek operation. When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised or the time-out expires, the message is retrieved if one exists, and its body is written to the screen. Then <xref:System.Messaging.MessageQueue.BeginPeek%2A> is called again to initiate a new asynchronous peek operation with the same time-out.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <param name="stateObject">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
        <summary>Initiates an asynchronous peek operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginPeek%2A> to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.  
  
 Use this overload to associate information with the operation that will be preserved throughout the operation's lifetime. The event handler can access this information by looking at the <xref:System.IAsyncResult.AsyncState%2A> property of the <xref:System.IAsyncResult> that is associated with the operation.  
  
 To use <xref:System.Messaging.MessageQueue.BeginPeek%2A>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiates an asynchronous peek operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.PeekCompleted> event, when a message arrives in the queue. The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> or by retrieving the result using the <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  
  
 Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution. To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.  
  
 Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns a <xref:System.IAsyncResult> that identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  
  
 This overload specifies a time-out and a state object. If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.PeekCompleted> event. Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> will throw an exception.  
  
 The state object associates state information with the operation. For example, if you call <xref:System.Messaging.MessageQueue.BeginPeek%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define. For an illustration of this scenario, see the Example section.  
  
 You can also use the state object to pass information across process threads. If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.  
  
 If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example creates an asynchronous peek operation, using the queue path ".\myQueue". It creates an event handler, `MyPeekCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate. <xref:System.Messaging.MessageQueue.BeginPeek%2A> is called, with a time-out of one minute. Each call to <xref:System.Messaging.MessageQueue.BeginPeek%2A> has a unique associated integer that identifies that particular operation. When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised or the time-out expired, the message, if one exists, is retrieved and its body and the operation-specific integer identifier are written to the screen. Then <xref:System.Messaging.MessageQueue.BeginPeek%2A> is called again to initiate a new asynchronous peek operation with the same time-out and the associated integer of the just completed operation.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <param name="stateObject">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> that will receive the notification of the asynchronous operation completion.</param>
        <summary>Initiates an asynchronous peek operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime. This overload receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <xref:System.Messaging.MessageQueue.PeekCompleted> event is not raised. The other overloads of <xref:System.Messaging.MessageQueue.BeginPeek%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.  
  
 The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  
  
 Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution. To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.  
  
 Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns a <xref:System.IAsyncResult> that identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  
  
 The state object associates state information with the operation. For example, if you call <xref:System.Messaging.MessageQueue.BeginPeek%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example creates an asynchronous peek operation. The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passing in: a time-out value of ten seconds; a unique integer that identifies that particular message; and a new instance of <xref:System.AsyncCallback> that identifies the event handler, `MyPeekCompleted`. When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the event handler peeks at the message and writes the message body and the integer message identifier to the screen.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</param>
        <param name="action">One of the <see cref="T:System.Messaging.PeekAction" /> values. Indicates whether to peek at the current message in the queue, or the next message.</param>
        <param name="state">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> that receives the notification of the asynchronous operation completion.</param>
        <summary>Initiates an asynchronous peek operation that has a specified time-out and that uses a specified cursor, a specified peek action, and a specified state object. The state object provides associated information throughout the lifetime of the operation. This overload receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired. The <xref:System.Messaging.MessageQueue.PeekCompleted> event is not raised. The other overloads of <xref:System.Messaging.MessageQueue.BeginPeek%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.  
  
 The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  
  
 Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution. To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.  
  
 Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns a <xref:System.IAsyncResult> that identifies the asynchronous operation started by the method. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  
  
 The state object associates state information with the operation. For example, if you call <xref:System.Messaging.MessageQueue.BeginPeek%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A value other than <see langword="PeekAction.Current" /> or <see langword="PeekAction.Next" /> was specified for the <paramref name="action" /> parameter.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="cursor" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>The method is not thread safe.</threadsafe>
        <summary>Initiates an asynchronous receive operation by telling Message Queuing to begin receiving a message and notify the event handler when finished.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiates an asynchronous receive operation that has no time-out. The operation is not complete until a message becomes available in the queue.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginReceive%2A> to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event when a message has been removed from the queue.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.  
  
 To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue. The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  
  
 Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution. To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.  
  
 Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  
  
 The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  
  
 If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions. If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation. Your event handler might contain functionality as shown in the following C# code.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example chains asynchronous requests. It assumes there is a queue on the local computer called "myQueue". The `Main` function begins the asynchronous operation that is handled by the `MyReceiveCompleted` routine. `MyReceiveCompleted` processes the current message and begins a new asynchronous receive operation.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 The following code example queues asynchronous requests. The call to <xref:System.Messaging.MessageQueue.BeginReceive%2A> uses the <xref:System.IAsyncResult.AsyncWaitHandle%2A> in its return value. The `Main` routine waits for all asynchronous operations to be completed before exiting.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <summary>Initiates an asynchronous receive operation that has a specified time-out. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginReceive%2A> to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.  
  
 To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue. The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> or retrieving the result using the <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  
  
 Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution. To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.  
  
 Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  
  
 If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  
  
 This overload specifies a time-out. If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event. Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> will throw an exception.  
  
 Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions. If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation. Your event handler might contain functionality as shown in the following C# code.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example creates an asynchronous receive operation. The code example creates an event handler, `MyReceiveCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event handler delegate. The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, passing in a time-out value of ten seconds. When a <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, the event handler receives the message and writes the message body to the screen.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly because it represents a negative number.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <param name="stateObject">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
        <summary>Initiates an asynchronous receive operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginReceive%2A> to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.  
  
 Use this overload to associate information with the operation that will be preserved throughout the operation's lifetime. The event handler can detect this information by looking at the <xref:System.IAsyncResult.AsyncState%2A> property of the <xref:System.IAsyncResult> that is associated with the operation.  
  
 To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue. The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> or retrieving the result using the <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  
  
 Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution. To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.  
  
 Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  
  
 The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  
  
 This overload specifies a time-out and a state object. If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event. Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> will throw an exception.  
  
 The state object associates state information with the operation. For example, if you call <xref:System.Messaging.MessageQueue.BeginReceive%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.  
  
 You can also use the state object to pass information across process threads. If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.  
  
 Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions. If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation. Your event handler might contain functionality as shown in the following C# code.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example creates an asynchronous receive operation. The code example creates an event handler, `MyReceiveCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event handler delegate. The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, passing in a time-out value of ten seconds and a unique integer that identifies that particular message. When a <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, the event handler receives the message and writes the message body and the integer message identifier to the screen.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <param name="stateObject">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> that will receive the notification of the asynchronous operation completion.</param>
        <summary>Initiates an asynchronous receive operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime. This overload receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is not raised. The other overloads of <xref:System.Messaging.MessageQueue.BeginReceive%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.  
  
 To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue. The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> or retrieving the result using the <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  
  
 Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution. To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.  
  
 Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  
  
 The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  
  
 The state object associates state information with the operation. For example, if you call <xref:System.Messaging.MessageQueue.BeginReceive%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.  
  
 You can also use the state object to pass information across process threads. If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.  
  
 Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions. If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation. Your event handler might contain functionality as shown in the following C# code.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example creates an asynchronous receive operation. The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passing in: a time-out value of ten seconds; a unique integer that identifies that particular message; and a new instance of <xref:System.AsyncCallback> that identifies the event handler, `MyReceiveCompleted`. When a <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, the event handler receives the message and writes the message body and the integer message identifier to the screen.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</param>
        <param name="state">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> that receives the notification of the asynchronous operation completion.</param>
        <summary>Initiates an asynchronous receive operation that has a specified time-out and uses a specified cursor and a specified state object. The state object provides associated information throughout the lifetime of the operation. This overload receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is not raised. The other overloads of <xref:System.Messaging.MessageQueue.BeginReceive%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.  
  
 To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue. The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> or retrieving the result using the <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.  
  
 Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution. To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.  
  
 Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.  
  
 The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started. You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called. However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete. In this case, use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.  
  
 The state object associates state information with the operation. For example, if you call <xref:System.Messaging.MessageQueue.BeginReceive%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.  
  
 You can also use the state object to pass information across process threads. If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.  
  
 Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions. If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation. Your event handler might contain functionality as shown in the following C# code.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="cursor" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Messaging.MessageQueue" /> can be read.</summary>
        <value>
          <see langword="true" /> if the <see cref="T:System.Messaging.MessageQueue" /> exists and the application can read from it; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> indicates whether the application is able to peek or receive messages from the queue. If <xref:System.Messaging.MessageQueue.CanRead%2A> is `true`, the <xref:System.Messaging.MessageQueue> can receive or peek messages from the queue. Otherwise, it cannot.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> is `false` if a queue is already open with exclusive read access (or if it's open with non-exclusive access and this <xref:System.Messaging.MessageQueue> requests exclusive access), or if the application does not have sufficient rights to access it. If your application tries to read from a queue when <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, access is denied.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.CanRead%2A> property.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Messaging.MessageQueue" /> can be written to.</summary>
        <value>
          <see langword="true" /> if the <see cref="T:System.Messaging.MessageQueue" /> exists and the application can write to it; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> indicates whether the application is able to send messages to the queue. If <xref:System.Messaging.MessageQueue.CanWrite%2A> is `true`, the <xref:System.Messaging.MessageQueue> can send messages to the queue. Otherwise, it cannot.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> is `false` if a queue is already open with exclusive write access (or if it's open with non-exclusive access and this <xref:System.Messaging.MessageQueue> requests exclusive access), or if the application does not have sufficient rights to access it. If your application tries to write to a queue when <xref:System.Messaging.MessageQueue.CanWrite%2A> is `false`, access is denied.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.CanWrite%2A> property.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the queue category.</summary>
        <value>A <see cref="T:System.Guid" /> that represents the queue category (Message Queuing type identifier), which allows an application to categorize its queues. The default is <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The queue category allows an application to categorize its queues. For example, you can place all Billing queues in one category and all Order queues in another.  
  
 The <xref:System.Messaging.MessageQueue.Category%2A> property provides access to the Message Queuing Type ID property (which is read/write), accessible through the **Queue Properties** dialog box in the Computer Management Console. You can define a new category. Although you can use <xref:System.Guid.NewGuid%2A> to create a category value that is unique across all <xref:System.Guid> values, such an action is unnecessary. The category value needs to be distinct only from other categories, not from all other <xref:System.Guid> values. For example, you can assign {00000000-0000-0000-0000-000000000001} as the <xref:System.Messaging.MessageQueue.Category%2A> for one set of queues and {00000000-0000-0000-0000-000000000002} as the <xref:System.Messaging.MessageQueue.Category%2A> for another set.  
  
 It is not necessary to set the <xref:System.Messaging.MessageQueue.Category%2A>. The value can be `null`.  
  
 Setting this property modifies the Message Queuing queue. Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.Category%2A> property.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The queue category was set to an invalid value.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears the connection cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When you call <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, the format names stored in the cache are removed and handles opened and stored in the cache are closed.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example calls <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Frees all resources allocated by the <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> frees all resources associated with a <xref:System.Messaging.MessageQueue>, including shared resources if appropriate. The system re-acquires these resources automatically if they are still available, for example when you call the <xref:System.Messaging.MessageQueue.Send%28System.Object%29> method, as in the following C# code.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 When you call <xref:System.Messaging.MessageQueue.Close%2A>, all <xref:System.Messaging.MessageQueue> properties that directly access the Message Queuing queue are cleared out. The <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, and <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> all remain as they were.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> does not always free the read and write handles to a queue, because they might be shared. You can take any of the following steps to ensure that <xref:System.Messaging.MessageQueue.Close%2A> frees the read and write handles to a queue:  
  
-   Create the <xref:System.Messaging.MessageQueue> with exclusive access. To do so, call the <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> or <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> constructor, and set the `sharedModeDenyReceive` parameter to `true`.  
  
-   Create the <xref:System.Messaging.MessageQueue> with connection caching disabled. To do so, call the <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> constructor and set the `enableConnectionCache` parameter to `false`.  
  
-   Disable connection caching. To do so, set the <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> property to `false`.  
  
 You should call <xref:System.Messaging.MessageQueue.Close%2A> for a queue before you delete the queue on the Message Queuing server. Otherwise, messages sent to the queue could throw exceptions or appear in the dead-letter queue.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example closes a Message Queuing queue.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new queue at the specified path on a Message Queuing server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path of the queue to create.</param>
        <summary>Creates a non-transactional Message Queuing queue at the specified path.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueue" /> that represents the new queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to create a non-transactional Message Queuing queue.  
  
 To create a new instance of the <xref:System.Messaging.MessageQueue> class in your application and bind it to an existing queue, use the <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor. To create a new queue in Message Queuing, call <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 The syntax for the `path` parameter depends on the type of queue it references, as shown in the following table.  
  
|Queue type|Syntax|  
|----------------|------------|  
|Public queue|`MachineName`\\`QueueName`|  
|Private queue|`MachineName`\\`Private$`\\`QueueName`|  
  
 Use "." for the local computer. For more syntax, see the <xref:System.Messaging.MessageQueue.Path%2A> property.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example creates public and private queues. It sends a message to selected queues.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is <see langword="null" /> or is an empty string ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A queue already exists at the specified path.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">The path of the queue to create.</param>
        <param name="transactional">
          <see langword="true" /> to create a transactional queue; <see langword="false" /> to create a non-transactional queue.</param>
        <summary>Creates a transactional or non-transactional Message Queuing queue at the specified path.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueue" /> that represents the new queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You can use this overload to create a transactional queue in Message Queuing. You can create a non-transactional queue, by setting the `transactional` parameter to `false` or by calling the other overload of <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 To create a new instance of the <xref:System.Messaging.MessageQueue> class in your application and bind it to an existing queue, use the <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor. To create a new queue in Message Queuing, call <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 The syntax for the `path` parameter depends on the type of queue it references, as shown in the following table.  
  
|Queue type|Syntax|  
|----------------|------------|  
|Public queue|`MachineName`\\`QueueName`|  
|Private queue|`MachineName`\\`Private$`\\`QueueName`|  
  
 Use "." for the local computer. For more syntax, see the <xref:System.Messaging.MessageQueue.Path%2A> property.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example creates public and private transactional queues. It sends a message to selected queues.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is <see langword="null" /> or is an empty string ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A queue already exists at the specified path.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Messaging.Cursor" /> for the current message queue.</summary>
        <returns>A new <see cref="T:System.Messaging.Cursor" /> for the current message queue. This cursor is used to maintain a specific location in the queue when reading the queue's messages.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time and date that the queue was created in Message Queuing.</summary>
        <value>A <see cref="T:System.DateTime" /> that represents the date and time at which the queue was created.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> refers to the queue on the Message Queuing server, not the <xref:System.Messaging.MessageQueue> instance.  
  
 If the queue exists, this property represents the time the queue was created, adjusted to the local time of the server on which the queue exists.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.CreateTime%2A> property.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the message property values to be used by default when the application sends messages to the queue.</summary>
        <value>A <see cref="T:System.Messaging.DefaultPropertiesToSend" /> that contains the default Message Queuing message property values used when the application sends objects other than <see cref="T:System.Messaging.Message" /> instances to the queue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When you send any object that is not of type <xref:System.Messaging.Message> to the queue, the <xref:System.Messaging.MessageQueue> inserts the object into a Message Queuing message. At that time, the <xref:System.Messaging.MessageQueue> applies to the message the property values you specify in the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property. Conversely, if you send a <xref:System.Messaging.Message> to the queue, these properties are already specified for the instance itself, so <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> is ignored for the <xref:System.Messaging.Message>.  
  
 Although you set the properties through the <xref:System.Messaging.MessageQueue> object, the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> refers to the properties of the messages that are sent to the queue, not the queue itself.  
  
 The default values for the properties are shown in the following table.  
  
|Property|Default value|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Zero (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|A zero-length array of bytes|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|Empty string ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example uses the priority of a message to determine default properties to send for the message.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The default properties could not be set for the queue, possibly because one of the properties is not valid.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue to be deleted.</param>
        <summary>Deletes a queue on a Message Queuing server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The syntax for the `path` parameter depends on the type of queue.  
  
|Queue type|Syntax|  
|----------------|------------|  
|Public queue|`MachineName`\\`QueueName`|  
|Private queue|`MachineName`\\`Private$`\\`QueueName`|  
  
 For more syntax, see the <xref:System.Messaging.MessageQueue.Path%2A> property.  
  
 Alternatively, you can use the <xref:System.Messaging.MessageQueue.FormatName%2A> or <xref:System.Messaging.MessageQueue.Label%2A> to describe the queue path.  
  
|Reference|Syntax|  
|---------------|------------|  
|Format name|FormatName:[ *format name* ]|  
|Label|Label:[ *label* ]|  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example deletes a Message Queuing queue, if it exists.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is <see langword="null" /> or is an empty string ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The syntax for the <paramref name="path" /> parameter is not valid.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether this <see cref="T:System.Messaging.MessageQueue" /> has exclusive access to receive messages from the Message Queuing queue.</summary>
        <value>
          <see langword="true" /> if this <see cref="T:System.Messaging.MessageQueue" /> has exclusive rights to receive messages from the queue; otherwise, <see langword="false" />. The default is <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> specifies the shared mode of the queue referenced by this <xref:System.Messaging.MessageQueue>. Set <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> to `true` to indicate that only this <xref:System.Messaging.MessageQueue> should have access to peek or receive messages from the queue with the specified <xref:System.Messaging.MessageQueue.Path%2A>. If another <xref:System.Messaging.MessageQueue> or another application is associated with the same queue resource, that instance or application will not be able to peek or receive messages, but it can still send them.  
  
 If <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> is `false`, the queue is available to multiple applications for sending, peeking, or receiving messages.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> property.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Disposes of the resources (other than memory) used by the <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Call <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> when you are finished using the <xref:System.Messaging.MessageQueue>. The <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> method leaves the <xref:System.Messaging.MessageQueue> in an unusable state. After calling <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, you must release all references to the <xref:System.Messaging.MessageQueue> so the memory it was occupying can be reclaimed by garbage collection.  
  
 You should call <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> before you release your last reference to the <xref:System.Messaging.MessageQueue>. Otherwise, the resources the <xref:System.Messaging.MessageQueue> is using will not be freed until garbage collection calls the <xref:System.Messaging.MessageQueue> object's destructor.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a cache of connections will be maintained by the application.</summary>
        <value>
          <see langword="true" /> to create and use a connection cache; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A connection cache is a list of references to structures that contain read or write handles to queues. When <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> is `true`, the <xref:System.Messaging.MessageQueue> borrows handles from the cache each time you call <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, or <xref:System.Messaging.MessageQueue.Receive%2A>, rather than open new handles. This can improve performance. Using a connection cache also insulates the <xref:System.Messaging.MessageQueue> from changes in the network topology.  
  
 If you create a new connection to a queue when the connection cache is full, the <xref:System.Messaging.MessageQueue> overwrites the least recently accessed structure with the new connection. You can clear the cache entirely by calling <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, for example, if the format names of the queues you are working with have changed so that the previous read and write handles are no longer valid.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> property.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the queue accepts only non-private (non-encrypted) messages.</summary>
        <value>One of the <see cref="T:System.Messaging.EncryptionRequired" /> values. The default is <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When you specify that encryption is required for the messages sent to a queue, only the message bodies are encrypted. The other members (for example, the <xref:System.Messaging.Message.Label%2A> and <xref:System.Messaging.Message.SenderId%2A> properties) cannot be encrypted.  
  
 Setting this property modifies the Message Queuing queue. Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change.  
  
 Encrypting a message makes the message private. You can specify the queue's encryption requirement to be `None`, `Body`, or `Optional` by setting the <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> property appropriately. The <xref:System.Messaging.Message.UseEncryption%2A> setting of the message must correspond to the encryption requirement of the queue. If the message is not encrypted but the queue specifies `Body`, or if the message is encrypted but the queue specifies `None`, the message is rejected by the queue. If the sending application requests a negative acknowledgment message in this event, Message Queuing indicates the message's rejection to the sending application. If the <xref:System.Messaging.Message.UseDeadLetterQueue%2A> property is `true`, a message that fails encryption is sent to the dead-letter queue. Otherwise, the message is lost.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> property.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The <see cref="T:System.IAsyncResult" /> that identifies the asynchronous peek operation to finish and from which to retrieve an end result.</param>
        <summary>Completes the specified asynchronous peek operation.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> associated with the completed asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When the <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> completes the operation that was initiated by the <xref:System.Messaging.MessageQueue.BeginPeek%2A> call. To do so, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> peeks the message.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> can specify a time-out, which causes the <xref:System.Messaging.MessageQueue.PeekCompleted> event to be raised if the time-out occurs before a message appears in the queue. When a time-out occurs without a message arriving in the queue, a subsequent call to <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> throws an exception.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is used to read the message that caused the <xref:System.Messaging.MessageQueue.PeekCompleted> event to be raised.  
  
 If you want to continue to asynchronously peek messages, you can again call <xref:System.Messaging.MessageQueue.BeginPeek%2A> after calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example creates an event handler named `MyPeekCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> to initiate an asynchronous peek operation on the queue that is located at the path ".\myQueue". When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the example peeks the message and writes its body to the screen. The example then calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> again to initiate a new asynchronous peek operation.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The syntax of the <paramref name="asyncResult" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The <see cref="T:System.IAsyncResult" /> that identifies the asynchronous receive operation to finish and from which to retrieve an end result.</param>
        <summary>Completes the specified asynchronous receive operation.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> associated with the completed asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> completes the operation that was initiated by the <xref:System.Messaging.MessageQueue.BeginReceive%2A> call. To do so, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> receives the message.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> can specify a time-out, which causes the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event to be raised if the time-out occurs before a message appears in the queue. When a time-out occurs without a message arriving in the queue, a subsequent call to <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> throws an exception.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is used to read (removing from the queue) the message that caused the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event to be raised.  
  
 If you want to continue to asynchronously receive messages, you can again call <xref:System.Messaging.MessageQueue.BeginReceive%2A> after calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example chains asynchronous requests. It assumes there is a queue on the local computer called "myQueue". The `Main` function begins the asynchronous operation that is handled by the `MyReceiveCompleted` routine. `MyReceiveCompleted` processes the current message and begins a new asynchronous receive operation.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The syntax of the <paramref name="asyncResult" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue to find.</param>
        <summary>Determines whether a Message Queuing queue exists at the specified path.</summary>
        <returns>
          <see langword="true" /> if a queue with the specified path exists; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Messaging.MessageQueue.Exists%28System.String%29> method determines whether a Message Queuing queue exists at a specified path. No method exists to determine whether a queue with a specified format name exists. For more information about the format name syntax and other path syntax forms, see the <xref:System.Messaging.MessageQueue.Path%2A> property.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> is an expensive operation. Use it only when it is necessary within the application.  
  
> [!NOTE]
>  The <xref:System.Messaging.MessageQueue.Exists%28System.String%29> method does not support the <xref:System.Messaging.MessageQueue.FormatName%2A> prefix.  
  
 The syntax for the `path` parameter depends on the type of queue, as shown in the following table.  
  
|Queue type|Syntax|  
|----------------|------------|  
|Public queue|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> cannot be called to verify the existence of a remote private queue.  
  
 For more syntax, see the <xref:System.Messaging.MessageQueue.Path%2A> property.  
  
 Alternatively, you can use the <xref:System.Messaging.MessageQueue.Label%2A> to describe the queue path.  
  
|Reference|Syntax|  
|---------------|------------|  
|Label|Label:[ `label` ]|  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|No|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example verifies whether a Message Queuing queue exists, and then deletes it.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> syntax is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.  
  
 -or-  
  
 The <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> method is being called on a remote private queue</exception>
        <exception cref="T:System.InvalidOperationException">The application used format name syntax when verifying queue existence.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the unique queue name that Message Queuing generated at the time of the queue's creation.</summary>
        <value>The name for the queue, which is unique on the network.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Messaging.MessageQueue.FormatName%2A> property contains the format name of the queue. Message Queuing uses the format name to identify which queue to open and how to access it. Unlike most of a queue's characteristics, the format name is not a Message Queuing application queue property, so you cannot access it through the Message Queuing management tool. The format name is simply a unique name for the queue, which Message Queuing generates when it creates the queue or which the application generates later.  
  
 If you specify a path using the path name syntax (such as `myComputer\myQueue`) rather than using the format name syntax when you read or write to the queue, the primary domain controller (which uses Active Directory) translates the <xref:System.Messaging.MessageQueue.Path%2A> into the associated <xref:System.Messaging.MessageQueue.FormatName%2A> before accessing the queue. If your application is working offline, you must use the format name syntax; otherwise, the primary domain controller will not be available to perform the path translation.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.FormatName%2A> property.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> is not set.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the formatter used to serialize an object into or deserialize an object from the body of a message read from or written to the queue.</summary>
        <value>The <see cref="T:System.Messaging.IMessageFormatter" /> that produces a stream to be written to or read from the message body. The default is <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Messaging.MessageQueue.Formatter%2A> property contains an instance of a formatter object, which transforms messages when your application reads or writes to the queue.  
  
 When the application sends message to the queue, the formatter serializes the object into a stream and inserts it into the message body. When reading from a queue, the formatter deserializes the message data into the <xref:System.Messaging.Message.Body%2A> property of a <xref:System.Messaging.Message>.  
  
 The <xref:System.Messaging.XmlMessageFormatter> is loosely coupled, so it is not necessary to have the same object type on the sender and receiver when using this format. The <xref:System.Messaging.ActiveXMessageFormatter> and <xref:System.Messaging.BinaryMessageFormatter> serialize the data into binary representation. The <xref:System.Messaging.ActiveXMessageFormatter> is used when sending or receiving COM components.  
  
 <xref:System.Messaging.BinaryMessageFormatter> and <xref:System.Messaging.ActiveXMessageFormatter> provide faster throughput than the <xref:System.Messaging.XmlMessageFormatter>. The <xref:System.Messaging.ActiveXMessageFormatter> allows interoperability with Visual Basic 6.0 Message Queuing applications.  
  
 When your application sends messages to the queue, the <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> applies only to those messages that use the default message properties, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. If you send a <xref:System.Messaging.Message> to the queue, Message Queuing uses the formatter defined in the <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property to serialize the body instead.  
  
 The <xref:System.Messaging.MessageQueue> class will always use a <xref:System.Messaging.Message> to receive or peek a message from the queue. The message is deserialized using the <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns all the messages that are in the queue.</summary>
        <returns>An array of type <see cref="T:System.Messaging.Message" /> that represents all the messages in the queue, in the same order as they appear in the Message Queuing queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> returns a static snapshot of the messages in the queue, not dynamic links to those messages. Therefore, you cannot use the array to modify the messages in the queue. If you want real-time, dynamic interaction with the queue (such as the ability to delete messages), call the <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> method, which returns a dynamic list of the messages in the queue.  
  
 Because <xref:System.Messaging.MessageQueue.GetAllMessages%2A> returns a copy of the messages in the queue at the time the method was called, the array does not reflect new messages that arrive in the queue or messages that are removed from the queue.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> retrieves only those properties not filtered out by the <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> property.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enumerates the messages in a queue. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> is deprecated. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> should be used instead.</summary>
        <returns>A <see cref="T:System.Collections.IEnumerator" /> that provides a dynamic connection to the messages in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">The name of the computer that contains the queue, without the two preceding backslashes (\\\\).</param>
        <summary>Gets the identifier of the computer on which the queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> is located.</summary>
        <returns>A <see cref="T:System.Guid" /> that represents a unique identifier for the computer on which the queue is located.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You can use a computer's identifier for two purposes, among others: to read the computer journal and to set security certificates. However, you cannot call <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> for a remote computer when you are working offline because the application must have access to the directory service on the domain controller.  
  
 The computer identifier (or machine identifier) is a <xref:System.Guid> that Message Queuing creates when a computer is added to the enterprise. Message Queuing combines the computer identifier with the `Machine` and `Journal` keywords to create the machine journal's format name, which has the syntax `Machine=<computeridentifier>;Journal`. The machine journal, which is also known as the journal queue, is a system queue that stores copies of application-generated messages when the <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> property is `true`.  
  
 This syntax for the journal is only valid when constructing the format name for the queue. The path name syntax is `MachineName`\\`Journal$`.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|No|  
|Local computer and direct format name|No|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example calls <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">The computer identifier could not be retrieved, possibly because the directory service is not available; for example, if you are working offline.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an enumerator object for all the messages in the queue. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> is deprecated. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> should be used instead.</summary>
        <returns>The <see cref="T:System.Messaging.MessageEnumerator" /> holding the messages that are contained in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> creates a dynamic list of all the messages in a queue. You can remove from the queue the message at the enumerator's current position by calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> for the <xref:System.Messaging.MessageEnumerator> that <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> returns.  
  
 Because the cursor is associated with the dynamic list of messages in the queue, the enumeration reflects any modification you make to the messages in the queue, if the message is beyond the current cursor position. For example, the enumerator can automatically access a lower-priority message placed beyond the cursor's current position, but not a higher-priority message inserted before that position. However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <xref:System.Messaging.MessageEnumerator.Reset%2A> for the <xref:System.Messaging.MessageEnumerator>.  
  
 The order of the messages in the enumeration reflects their order in the queue, so higher-priority messages will appear before lower-priority ones.  
  
 If you want a static snapshot of the messages in the queue rather than a dynamic connection to them, call <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. This method returns an array of <xref:System.Messaging.Message> objects, which represent the messages at the time the method was called.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example gets a dynamic list of messages in a queue and counts all messages with the <xref:System.Messaging.Message.Priority%2A> property set to <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an enumerator object for all the messages in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.MessageEnumerator" /> holding the messages that are contained in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> creates a dynamic list of all the messages in a queue. You can remove from the queue the message at the enumerator's current position by calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> for the <xref:System.Messaging.MessageEnumerator> that <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> returns.  
  
 Because the cursor is associated with the dynamic list of messages in the queue, the enumeration reflects any modification you make to the messages in the queue, if the message is beyond the current cursor position. For example, the enumerator can automatically access a lower-priority message placed beyond the cursor's current position, but not a higher-priority message inserted before that position. However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <xref:System.Messaging.MessageEnumerator.Reset%2A> for the <xref:System.Messaging.MessageEnumerator>.  
  
 The order of the messages in the enumeration reflects their order in the queue, so higher-priority messages will appear before lower-priority ones.  
  
 If you want a static snapshot of the messages in the queue rather than a dynamic connection to them, call <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. This method returns an array of <xref:System.Messaging.Message> objects, which represent the messages at the time the method was called.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an enumerator object for a dynamic listing of the public queues on the network.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provides forward-only cursor semantics to enumerate through all public queues on the network.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueueEnumerator" /> that provides a dynamic listing of all the public message queues on the network.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This overload of <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> returns an enumeration of all the public queues that are on the network.  
  
 Because the cursor is associated with a dynamic listing, the enumeration reflects any modification you make to a queue list for queues deleted or added beyond the cursor's current position. Additions or deletion of queues located before the cursor's current position are not reflected. For example, the enumerator can automatically access a queue appended beyond the cursor position but not one inserted before that position. However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> for the <xref:System.Messaging.MessageQueueEnumerator>.  
  
 There is no defined ordering of queues in a network. An enumerator does not order them, for example, by computer, label, public or private status, or any other accessible criteria.  
  
 If you want a static snapshot of the queues on the network rather than a dynamic connection to them, call <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> or <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Each of these two methods returns an array of <xref:System.Messaging.MessageQueue> objects, which represent the queues at the time the method was called.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|No|  
|Local computer and direct format name|No|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example iterates through all the message queues in the network, and examines the path for each queue. Finally, it displays the number of public queues on the network.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">A <see cref="T:System.Messaging.MessageQueueCriteria" /> that contains the criteria used to filter the available message queues.</param>
        <summary>Provides forward-only cursor semantics to enumerate through all public queues on the network that meet the specified criteria.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueueEnumerator" /> that provides a dynamic listing of the public message queues on the network that satisfy the restrictions specified by the <paramref name="criteria" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This overload of <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> returns a listing of all the public queues on the network that satisfy criteria defined in the application criteria. You can specify the criteria to include, for example, queue creation or modification time, computer name, label, category, or any combination of these.  
  
 Because the cursor is associated with a dynamic listing, the enumeration reflects any modification you make to a queue that occurs beyond the cursor's current position. Changes to queues located before the cursor's current position are not reflected. For example, the enumerator can automatically access a queue appended beyond the cursor position but not one inserted before that position. However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> for the <xref:System.Messaging.MessageQueueEnumerator>.  
  
 There is no defined ordering of queues in a network. An enumerator does not order them, for example, by computer, label, public or private status, or any other accessible criteria.  
  
 If you want a static snapshot of the queues on the network rather than a dynamic connection to them, specify criteria for <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> or call <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Each of these two methods returns an array of <xref:System.Messaging.MessageQueue> objects, which represent the queues at the time the method was called. Calling <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, or <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> provides the same results as calling <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> with the filtering criteria of <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, and <xref:System.Messaging.MessageQueue.MachineName%2A>, respectively.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|No|  
|Local computer and direct format name|No|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example iterates through message queues and displays the path of each queue that was created in the last day and that exists on the computer "MyComputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">The computer from which to retrieve the private queues.</param>
        <summary>Retrieves all the private queues on the specified computer.</summary>
        <returns>An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved private queues.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> retrieves a static snapshot of the queues on a specified computer.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example retrieves lists of queues.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter is <see langword="null" /> or an empty string ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves all the public queues on the network.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves all the public queues on the network.</summary>
        <returns>An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload if you want a complete list of all the public queues on the network. If you want to restrict the list by certain criteria, such as <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, or last modified time use another overload of this method. (Alternatively, you can use <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, or <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> retrieves a static snapshot of the queues. To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|No|  
|Local computer and direct format name|No|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example retrieves lists of queues.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">A <see cref="T:System.Messaging.MessageQueueCriteria" /> that contains the criteria used to filter the queues.</param>
        <summary>Retrieves all the public queues on the network that meet the specified criteria.</summary>
        <returns>An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If you want to filter all the public queues on the network by label, category, or computer name, the <xref:System.Messaging.MessageQueue> class contains specific methods that provide that functionality (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, and <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, respectively). Use this overload to get a list of all the public queues on the network that meet more than one of these criteria (for example, if you want to specify both a label and a category). You can also filter by message criteria other than <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, and <xref:System.Messaging.MessageQueue.MachineName%2A>. For example, you use this overload to filter by a queue's last-modified time. Simply create a new instance of the <xref:System.Messaging.MessageQueueCriteria> class, set the appropriate properties in the instance, and pass the instance as the `criteria` parameter.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> retrieves a static snapshot of the queues. To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|No|  
|Local computer and direct format name|No|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example retrieves lists of queues.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">A <see cref="T:System.Guid" /> that groups the set of queues to be retrieved.</param>
        <summary>Retrieves all the public queues on the network that belong to the specified category.</summary>
        <returns>An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to filter the public queues by category. The <xref:System.Messaging.MessageQueue.Category%2A> property provides access to the Message Queuing type ID property (which is read/write) of a particular queue. Although you can use <xref:System.Guid.NewGuid%2A> to create a category value that is unique across all <xref:System.Guid> values, it is not necessary. The category value needs to be distinct only from other categories, not from all other <xref:System.Guid> values. For example, you can assign {00000000-0000-0000-0000-000000000001} as the <xref:System.Messaging.MessageQueue.Category%2A> for one set of queues and {00000000-0000-0000-0000-000000000002} as the <xref:System.Messaging.MessageQueue.Category%2A> for another set.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> retrieves a static snapshot of the queues. To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. You can specify the category as part of the <xref:System.Messaging.MessageQueueCriteria> you pass into the method.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|No|  
|Local computer and direct format name|No|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example retrieves lists of queues.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">A label that groups the set of queues to be retrieved.</param>
        <summary>Retrieves all the public queues on the network that carry the specified label.</summary>
        <returns>An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to filter the public queues by label.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> retrieves a static snapshot of the queues. To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. You can specify the label as part of the <xref:System.Messaging.MessageQueueCriteria> you pass into the method.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|No|  
|Local computer and direct format name|No|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example retrieves lists of queues.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="label" /> parameter is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">The name of the computer that contains the set of public queues to be retrieved.</param>
        <summary>Retrieves all the public queues that reside on the specified computer.</summary>
        <returns>An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the public queues on the computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to filter the public queues by computer.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> retrieves a static snapshot of the queues. To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. You can specify the computer name as part of the <xref:System.Messaging.MessageQueueCriteria> you pass into the method.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|No|  
|Local computer and direct format name|No|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example retrieves lists of queues.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter has incorrect syntax.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves the security context that MSMQ associates with the current user (thread identity) at the time of this call.</summary>
        <returns>A <see cref="T:System.Messaging.SecurityContext" /> object that contains the security context.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the unique Message Queuing identifier of the queue.</summary>
        <value>A <see cref="P:System.Messaging.MessageQueue.Id" /> that represents the message identifier generated by the Message Queuing application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing sets the <xref:System.Messaging.MessageQueue.Id%2A> property when it creates the queue. This property is only available for public queues.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.Id%2A> property.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies that no size restriction exists for a queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is frequently used when setting <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> or <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 The following code example demonstrates the use of the <xref:System.Messaging.MessageQueue.InfiniteQueueSize> member.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies that no time-out exists for methods that peek or receive messages.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> supports two types of message retrieval: synchronous and asynchronous. The synchronous methods, <xref:System.Messaging.MessageQueue.Peek%2A> and <xref:System.Messaging.MessageQueue.Receive%2A>, cause the process thread to wait a specified time interval for a new message to arrive in the queue. If the specified time interval is <xref:System.Messaging.MessageQueue.InfiniteTimeout>, the process thread remains blocked until a new message is available. On the other hand, <xref:System.Messaging.MessageQueue.BeginPeek%2A> and <xref:System.Messaging.MessageQueue.BeginReceive%2A> (the asynchronous methods), allow the main application tasks to continue in a separate thread until a message arrives in the queue.  
  
   
  
## Examples  
 The following code example demonstrates the use of the <xref:System.Messaging.MessageQueue.InfiniteTimeout> member.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the queue description.</summary>
        <value>The label for the message queue. The default is an empty string ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The maximum length of a message queue label is 124 characters.  
  
 The <xref:System.Messaging.MessageQueue.Label%2A> property does not need to be unique across all queues. However, if multiple queues share the same <xref:System.Messaging.MessageQueue.Label%2A>, you cannot use the <xref:System.Messaging.MessageQueue.Send%28System.Object%29> method to broadcast a message to all of them. If you use the label syntax for the <xref:System.Messaging.MessageQueue.Path%2A> property when you send the message, an exception will be thrown if the <xref:System.Messaging.MessageQueue.Label%2A> is not unique.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.Label%2A> property.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The label was set to an invalid value.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the last time the properties of a queue were modified.</summary>
        <value>A <see cref="T:System.DateTime" /> that indicates when the queue properties were last modified.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The last modification time includes when the queue was created and any <xref:System.Messaging.MessageQueue> property that modifies the Message Queuing queue, such as <xref:System.Messaging.MessageQueue.BasePriority%2A>. The value of the <xref:System.Messaging.MessageQueue.LastModifyTime%2A> property represents the system time of the local computer.  
  
 You must call <xref:System.Messaging.MessageQueue.Refresh%2A> before getting the <xref:System.Messaging.MessageQueue.LastModifyTime%2A> property; otherwise, the modification time associated with this <xref:System.Messaging.MessageQueue> might not be current.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.LastModifyTime%2A> property.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the computer where the Message Queuing queue is located.</summary>
        <value>The name of the computer where the queue is located. The Message Queuing default is ".", the local computer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Messaging.MessageQueue.MachineName%2A> is an integral component of the friendly name syntax of the queue <xref:System.Messaging.MessageQueue.Path%2A>. The following table shows the syntax you should use for a queue of a specified type when you want to identify the queue path using its friendly name.  
  
|Queue type|Syntax|  
|----------------|------------|  
|Public queue|`MachineName`\\`QueueName`|  
|Private queue|`MachineName`\\`Private$`\\`QueueName`|  
|Journal queue|`MachineName`\\`QueueName`\\`Journal$`|  
|Machine journal queue|`MachineName`\\`Journal$`|  
|Machine dead-letter queue|`MachineName`\\`Deadletter$`|  
|Machine transactional dead-letter queue|`MachineName`\\`XactDeadletter$`|  
  
 Use "." for the local computer when specifying the <xref:System.Messaging.MessageQueue.MachineName%2A>. Only the computer name is recognized for this property, for example, `Server0`. The <xref:System.Messaging.MessageQueue.MachineName%2A> property does not support the IP address format.  
  
 If you define the <xref:System.Messaging.MessageQueue.Path%2A> in terms of the <xref:System.Messaging.MessageQueue.MachineName%2A>, the application throws an exception when working offline because the domain controller is required for path translation. Therefore, you must use the <xref:System.Messaging.MessageQueue.FormatName%2A> for the <xref:System.Messaging.MessageQueue.Path%2A> syntax when working offline.  
  
 The <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, and <xref:System.Messaging.MessageQueue.QueueName%2A> properties are related. Changing the <xref:System.Messaging.MessageQueue.MachineName%2A> property causes the <xref:System.Messaging.MessageQueue.Path%2A> property to change. It is built from the new <xref:System.Messaging.MessageQueue.MachineName%2A> and the <xref:System.Messaging.MessageQueue.QueueName%2A>. Changing the <xref:System.Messaging.MessageQueue.Path%2A> (for example, to use the format name syntax) resets the <xref:System.Messaging.MessageQueue.MachineName%2A> and <xref:System.Messaging.MessageQueue.QueueName%2A> properties to refer to the new queue. If the <xref:System.Messaging.MessageQueue.QueueName%2A> property is empty, the <xref:System.Messaging.MessageQueue.Path%2A> is set to the Journal queue of the computer you specify.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.MachineName%2A> property.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The name of the computer is not valid, possibly because the syntax is incorrect.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum size of the journal queue.</summary>
        <value>The maximum size, in kilobytes, of the journal queue. The Message Queuing default specifies that no limit exists.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> provides access to the Message Queuing journal storage limit. It is relevant only when <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> is `true`. Setting this property modifies the Message Queuing queue. Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change  
  
 If you store messages in a journal or dead-letter queue, you should periodically clear the queue to remove messages that are no longer needed. Messages in such a queue count toward the message quota for the computer where the queue resides. (The administrator sets the computer quota.)  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> property.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The maximum journal queue size was set to an invalid value.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum size of the queue.</summary>
        <value>The maximum size, in kilobytes, of the queue. The Message Queuing default specifies that no limit exists.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> provides access to the Message Queuing message storage limit, which is separate from the computer's message quota that the administrator defines. For more information about the message quota, see <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Setting this property modifies the Message Queuing queue. Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change  
  
 If an attempt is made to exceed either the maximum queue size or the computer message quota, messages might be lost. When the queue quota is reached, Message Queuing notifies the administration queue of the sending application to indicate that the queue is full, by returning a negative acknowledgment message. Message Queuing continues to send negative acknowledgments until the total size of the messages in the queue drops below the limit.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> property.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The maximum queue size contains a negative value.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the property filter for receiving or peeking messages.</summary>
        <value>The <see cref="T:System.Messaging.MessagePropertyFilter" /> used by the queue to filter the set of properties it receives or peeks for each message.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This filter is a set of Boolean values restricting the message properties that the <xref:System.Messaging.MessageQueue> receives or peeks. When the <xref:System.Messaging.MessageQueue> receives or peeks a message from the server queue, it retrieves only those properties for which the <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> value is `true`.  
  
 The following shows initial property values for the <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> property. These settings are identical to calling <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> on a <xref:System.Messaging.MessagePropertyFilter>.  
  
|Property|Default value|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example uses the <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> to restrict the message properties received.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The filter is <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Introduced in MSMQ 3.0. Gets or sets the multicast address associated with the queue.</summary>
        <value>A <see cref="T:System.String" /> that contains a valid multicast address (in the form shown below) or <see langword="null" />, which indicates that the queue is not associated with a multicast address.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Messaging.MessageQueue.MulticastAddress%2A> property is used to associate a non-transactional queue with a multicast address that can be used when sending messages. You cannot associate a transactional queue with a multicast address. When the sending application sends messages to a multicast address, Message Queuing sends a copy of the message to every queue associated with that address.  
  
 IP multicast addresses must be in the class D range from 224.0.0.0 to 239.255.255.255, which corresponds to setting the first four high-order bits equal to 1110. However, only certain ranges of addresses in this range are unreserved and available for sending multicast messages. For the latest list of reserved multicast addresses, see the [Internet Assigned Number Authority (IANA) Internet Multicast Addresses](https://go.microsoft.com/fwlink/?linkid=3859) Web page. There are no restrictions on the port number.  
  
 If several source computers are sending multicast messages and you want a specific queue to receive messages from only one source computer, each source computer must send messages to a different combination of IP address and port number.  
  
 To dissociate a queue from a multicast address, set the <xref:System.Messaging.MessageQueue.MulticastAddress%2A> property to a zero-length string. Do not set it to `null`, as this will result in a <xref:System.ArgumentNullException>.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the queue's path. Setting the <see cref="P:System.Messaging.MessageQueue.Path" /> causes the <see cref="T:System.Messaging.MessageQueue" /> to point to a new queue.</summary>
        <value>The queue that is referenced by the <see cref="T:System.Messaging.MessageQueue" />. The default depends on which <see cref="M:System.Messaging.MessageQueue.#ctor" /> constructor you use; it is either <see langword="null" /> or is specified by the constructor's <paramref name="path" /> parameter.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The syntax for the <xref:System.Messaging.MessageQueue.Path%2A> property depends on the type of queue it points to, as shown in the following table.  
  
|Queue type|Syntax|  
|----------------|------------|  
|Public queue|`MachineName`\\`QueueName`|  
|Private queue|`MachineName`\\`Private$`\\`QueueName`|  
|Journal queue|`MachineName`\\`QueueName`\\`Journal$`|  
|Machine journal queue|`MachineName`\\`Journal$`|  
|Machine dead-letter queue|`MachineName`\\`Deadletter$`|  
|Machine transactional dead-letter queue|`MachineName`\\`XactDeadletter$`|  
  
 Use "." to represent the local computer.  
  
 The <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, and <xref:System.Messaging.MessageQueue.QueueName%2A> properties are related. Changing the <xref:System.Messaging.MessageQueue.MachineName%2A> property causes the <xref:System.Messaging.MessageQueue.Path%2A> property to change. It is built from the new <xref:System.Messaging.MessageQueue.MachineName%2A> and the <xref:System.Messaging.MessageQueue.QueueName%2A>. Changing the <xref:System.Messaging.MessageQueue.Path%2A> (for example, to use the format name syntax) resets the <xref:System.Messaging.MessageQueue.MachineName%2A> and <xref:System.Messaging.MessageQueue.QueueName%2A> properties to refer to the new queue.  
  
 Alternatively, you can use the <xref:System.Messaging.MessageQueue.FormatName%2A> or <xref:System.Messaging.MessageQueue.Label%2A> to describe the queue path, as shown in the following table.  
  
|Reference|Syntax|Example|  
|---------------|------------|-------------|  
|Format name|`FormatName:` [ *format name* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Label|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 If you use the label syntax for the <xref:System.Messaging.MessageQueue.Path%2A> property when you send the message, an exception will be thrown if the <xref:System.Messaging.MessageQueue.Label%2A> is not unique.  
  
 To work offline, you must use the format name syntax, rather than the friendly name syntax in the first table. Otherwise, an exception is thrown because the primary domain controller (on which Active Directory resides) is not available to resolve the path to the format name.  
  
 Setting a new path closes the message queue and releases all handles.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|Yes|  
  
> [!NOTE]
>  In workgroup mode you can only use private queues. You specify the path using the private queue syntax `MachineName`\\`Private$`\\`QueueName`.  
  
   
  
## Examples  
 The following code example creates new <xref:System.Messaging.MessageQueue> objects using various path name syntax types. In each case, it sends a message to the queue whose path is defined in the constructor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The path is not valid, possibly because the syntax is not valid.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>The method is not thread safe.</threadsafe>
        <summary>Returns a copy of the first message in the queue without removing the message from the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns without removing (peeks) the first message in the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />. The <see cref="M:System.Messaging.MessageQueue.Peek" /> method is synchronous, so it blocks the current thread until a message becomes available.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> that represents the first message in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to peek a queue, or to wait until a message exists in the queue.  
  
 The <xref:System.Messaging.MessageQueue.Peek%2A> method reads, but does not remove, the first message from the queue. Therefore, repeated calls to <xref:System.Messaging.MessageQueue.Peek%2A> return the same message, unless a higher priority message arrives in the queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method, on the other hand, both reads and removes the first message from the queue. Repeated calls to <xref:System.Messaging.MessageQueue.Receive%2A>, therefore, return different messages.  
  
 Message Queuing orders messages in the queue according to priority and arrival time. A newer message is placed before an older one only if it is of a higher priority.  
  
 Use <xref:System.Messaging.MessageQueue.Peek%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. Because this overload does not specify a time-out, the application might wait indefinitely. If you need the application processing to continue without waiting, use the asynchronous <xref:System.Messaging.MessageQueue.BeginPeek%2A> method. Alternatively, you can specify a time-out for a message to arrive in the queue by using the overload of <xref:System.Messaging.MessageQueue.Peek%2A> that specifies a time-out.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following examples use the <xref:System.Messaging.MessageQueue.Peek%2A> method on a queue.  
  
 In the first example, the application waits until a message becomes available in the queue. Note that the first example does not access the message that arrives; it merely pauses processing until a message arrives. If a message already exists in the queue, it will return immediately.  
  
 In the second example, a message that contains an application-defined `Order` class is sent to the queue, and then peeked from the queue.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the maximum time to wait for the queue to contain a message.</param>
        <summary>Returns without removing (peeks) the first message in the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />. The <see cref="M:System.Messaging.MessageQueue.Peek" /> method is synchronous, so it blocks the current thread until a message becomes available or the specified time-out occurs.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> that represents the first message in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to peek a queue, or to wait a specified period of time until a message exists in the queue. The method returns immediately if a message already exists in the queue.  
  
 The <xref:System.Messaging.MessageQueue.Peek%2A> method reads, but does not remove, the first message from the queue. Therefore, repeated calls to <xref:System.Messaging.MessageQueue.Peek%2A> return the same message, unless a higher priority message arrives in the queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method, on the other hand, both reads and removes the first message from the queue. Repeated calls to <xref:System.Messaging.MessageQueue.Receive%2A>, therefore, return different messages.  
  
 Message Queuing orders messages in the queue according to priority and arrival time. A newer message is placed before an older one only if it is of a higher priority.  
  
 Use <xref:System.Messaging.MessageQueue.Peek%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread will be blocked up to the specified period of time, or indefinitely if you indicated <xref:System.Messaging.MessageQueue.InfiniteTimeout>. If you need the application processing to continue without waiting, use the asynchronous <xref:System.Messaging.MessageQueue.BeginPeek%2A> method.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example uses the <xref:System.Messaging.MessageQueue.Peek%2A> method with a time-out of zero to check whether the queue is empty.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the maximum time to wait for the queue to contain a message.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</param>
        <param name="action">One of the <see cref="T:System.Messaging.PeekAction" /> values. Indicates whether to peek at the current message in the queue, or the next message.</param>
        <summary>Returns without removing (peeks) the current or next message in the queue, using the specified cursor. The <see cref="M:System.Messaging.MessageQueue.Peek" /> method is synchronous, so it blocks the current thread until a message becomes available or the specified time-out occurs.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that represents a message in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to peek a queue, or to wait a specified period of time until a message exists in the queue. The method returns immediately if a message already exists in the queue.  
  
 The <xref:System.Messaging.MessageQueue.Peek%2A> method reads, but does not remove, a message from the queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method, on the other hand, both reads and removes a message from the queue.  
  
 Use <xref:System.Messaging.MessageQueue.Peek%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread is blocked up to the specified period of time, or indefinitely if you indicated <xref:System.Messaging.MessageQueue.InfiniteTimeout>. If you need the application processing to continue without waiting, use the asynchronous <xref:System.Messaging.MessageQueue.BeginPeek%2A> method.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A value other than <see langword="PeekAction.Current" /> or <see langword="PeekAction.Next" /> was specified for the <paramref name="action" /> parameter.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="cursor" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid. Possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Peeks a message that matches a given correlation identifier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to peek.</param>
        <summary>Peeks the message that matches the given correlation identifier and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method looks in the queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter. If no message is found that matches the `correlationID` parameter, an exception is thrown.  
  
 The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.  
  
 Two other methods allow you to peek messages in a queue. The <xref:System.Messaging.MessageQueue.Peek%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example sends and receives a message that contains an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="correlationId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to peek.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <summary>Peeks the message that matches the given correlation identifier and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method looks in the queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter. If no message is found that matches the `correlationID` parameter, and no new message arrives in the queue within the period specified by the `timeout` parameter, an exception is thrown.  
  
 The `timeout` parameter does not specify the total running time for this method. Rather, it specifies the time to wait for a new message to arrive in the queue. Each time a new message arrives, this method examines the <xref:System.Messaging.Message.CorrelationId%2A> of the new message to see if it matches the `correlationId` parameter. If not, this method starts the time-out period over and waits for another new message to arrive. Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.CorrelationId%2A> matches the `correlationId` parameter.  
  
 The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.  
  
 Two other methods allow you to peek messages in a queue. The <xref:System.Messaging.MessageQueue.Peek%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive before the time-out expired.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a copy of the message that has the specified message identifier without removing the message from the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to peek.</param>
        <summary>Peeks the message whose message identifier matches the <paramref name="id" /> parameter.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> to read, without removing from the queue, a message that has a known message identifier. The identifier of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter. This overload throws an exception if the queue does not currently contain the message.  
  
 Two additional methods allow you to peek messages in a queue: <xref:System.Messaging.MessageQueue.Peek%2A> and <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. The <xref:System.Messaging.MessageQueue.Peek%2A> method returns the first message in the queue; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> returns an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No message with the specified <paramref name="id" /> exists.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to peek.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <summary>Peeks the message whose message identifier matches the <paramref name="id" /> parameter. Waits until the message appears in the queue or a time-out occurs.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> to read, without removing from the queue, a message that has a known message identifier. The identifier of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter. This overload throws an exception if the queue does not currently contain the message and a new message does not arrive before the time-out occurs.  
  
 The `timeout` parameter does not specify the total running time for this method. Rather, it specifies the time to wait for a new message to arrive in the queue. Each time a new message arrives, this method examines the <xref:System.Messaging.Message.Id%2A> of the new message to see if it matches the `id` parameter. If not, this method starts the time-out period over and waits for another new message to arrive. Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.Id%2A> matches the `id` parameter.  
  
 Two additional methods allow you to peek messages in a queue: <xref:System.Messaging.MessageQueue.Peek%2A> and <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. The <xref:System.Messaging.MessageQueue.Peek%2A> method returns the first message in the queue; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> returns an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="id" /> does not exist in the queue and did not arrive before the period specified by the <paramref name="timeout" /> parameter expired.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Introduced in MSMQ 3.0. Peeks at a specific message from the queue. The message can be specified by a lookup identifier or by its position at the front or end of the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to peek at.</param>
        <summary>Introduced in MSMQ 3.0. Peeks at the message that matches the given lookup identifier from a non-transactional queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.LookupId" /> property matches the <paramref name="lookupId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to read a message with a known lookup identifier without removing it from the queue. This method throws an exception immediately if the message is not in the queue.  
  
 The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.  
  
 To read a message with a specified lookup identifier and remove it from the queue, use the <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> method.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="lookupId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">One of the <see cref="T:System.Messaging.MessageLookupAction" /> values, specifying how the message is read in the queue. Specify one of the following:  
  
 <see langword="MessageLookupAction.Current" />: Peeks at the message specified by <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.Next" />: Peeks at the message following the message specified by <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.Previous" />: Peeks at the message preceding the message specified by <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.First" />: Peeks at the first message in the queue. The <paramref name="lookupId" /> parameter must be set to 0.  
  
 <see langword="MessageLookupAction.Last" />: Peeks at the last message in the queue. The <paramref name="lookupId" /> parameter must be set to 0.</param>
        <param name="lookupId">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to peek at, or 0. 0 is used when accessing the first or last message in the queue.</param>
        <summary>Introduced in MSMQ 3.0. Peeks at a specific message from the queue. The message can be specified by a lookup identifier or by its position at the front or end of the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> specified by the <paramref name="action" /> and <paramref name="lookupId" /> parameters passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to read a message with a known lookup identifier without removing it from the queue. This method throws an exception immediately if the message is not in the queue.  
  
 The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.  
  
 To read a message with a specified identifier and remove it from the queue, use the <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> method.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="lookupId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="action" /> parameter is not one of the <see cref="T:System.Messaging.MessageLookupAction" /> members.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a message is read without being removed from the queue. This is a result of the asynchronous operation, <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> is used in asynchronous processing to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message is available in the queue.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is used to complete the operation initiated by a call to <xref:System.Messaging.MessageQueue.BeginPeek%2A> and peek the message when the <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised.  
  
 When you create a <xref:System.Messaging.PeekCompletedEventHandler> delegate, you identify the method that will handle the event. To associate the event with your event handler, add an instance of the delegate to the event. The event handler is called whenever the event occurs, unless you remove the delegate. For more information about event handler delegates, see [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 The following code example creates an event handler named `MyPeekCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> to initiate an asynchronous peek operation on the queue that is located at the path ".\myQueue". When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the example peeks the message and writes its body to the screen. The example then calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> again to initiate a new asynchronous peek operation  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deletes all the messages contained in the queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Purging the queue causes Message Queuing to set the queue modification flag, which affects the <xref:System.Messaging.MessageQueue.LastModifyTime%2A> property. Messages that are purged from the queue are lost; they are not sent to the dead-letter queue or the journal queue.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the friendly name that identifies the queue.</summary>
        <value>The name that identifies the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />. The value cannot be <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You can combine the <xref:System.Messaging.MessageQueue.QueueName%2A> with the <xref:System.Messaging.MessageQueue.MachineName%2A> to create a friendly <xref:System.Messaging.MessageQueue.Path%2A> name for the queue. The syntax for the friendly name variation of the <xref:System.Messaging.MessageQueue.Path%2A> property depends on the type of queue, as shown in the following table.  
  
|Queue type|Syntax|  
|----------------|------------|  
|Public queue|`MachineName`\\`QueueName`|  
|Private queue|`MachineName`\\`Private$`\\`QueueName`|  
|Journal queue|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Use "." to represent the local computer.  
  
 Changing the <xref:System.Messaging.MessageQueue.QueueName%2A> property affects the <xref:System.Messaging.MessageQueue.Path%2A> property. If you set the <xref:System.Messaging.MessageQueue.QueueName%2A> without setting the <xref:System.Messaging.MessageQueue.MachineName%2A> property, the <xref:System.Messaging.MessageQueue.Path%2A> property becomes .\\`QueueName`. Otherwise, the <xref:System.Messaging.MessageQueue.Path%2A> becomes `MachineName`\\`QueueName`.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|Yes|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.QueueName%2A> property.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The queue name is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle used to read messages from the message queue.</summary>
        <value>A handle to the native queue object that you use for peeking and receiving messages from the queue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Messaging.MessageQueue.ReadHandle%2A> provides a native Windows handle to the message queue object that is used for peeking and receiving messages from the queue. If you change the path of the queue, the handle is closed and reopened with a new value.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>The method is not thread safe.</threadsafe>
        <summary>Receives the first message in the queue, removing it from the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" />. This call is synchronous, and blocks the current thread of execution until a message is available.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to receive a message from a queue, or wait until there are messages in the queue.  
  
 The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue. Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue, or new, higher priority messages.  
  
 To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method. The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.  
  
 Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. Because this overload of the <xref:System.Messaging.MessageQueue.Receive%2A> method specifies an infinite time-out, the application might wait indefinitely. If the application processing should continue without waiting for the message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example receives a message from a queue and outputs information about that message to the screen.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the first message available in the transactional queue referenced by the <see cref="T:System.Messaging.MessageQueue" />. This call is synchronous, and blocks the current thread of execution until a message is available.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to receive a message from a transactional queue using the internal transaction context defined by the `transaction` parameter, or wait until there are messages in the queue.  
  
 The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue. Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue.  
  
 Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method. The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>. Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there would be nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. Because this overload of the <xref:System.Messaging.MessageQueue.Receive%2A> method specifies an infinite time-out, the application might wait indefinitely. If the application processing should continue without waiting for the message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example connects to a transactional queue on the local computer and sends a message to the queue. It then receives the message that contains an order. If it encounters a non-transactional queue, it will throw and exception and rollback the transaction.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.  
  
 -or-  
  
 The queue is non-transactional.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" />. This call is synchronous, and blocks the current thread of execution until a message is available.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to receive a message from a queue using a transaction context defined by the `transactionType` parameter, or wait until there are messages in the queue.  
  
 Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message. Specify `Single` if you want to receive the message as a single internal transaction. You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.  
  
 The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue. Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue.  
  
 If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method. The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>. Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there would be nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. Because this overload of the <xref:System.Messaging.MessageQueue.Receive%2A> method specifies an infinite time-out, the application might wait indefinitely. If the application processing should continue without waiting for the message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <summary>Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" /> and waits until either a message is available in the queue, or the time-out expires.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to receive a message and return in a specified period of time if there are no messages in the queue.  
  
 The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, removing it from the queue. Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue, or new, higher priority messages.  
  
 To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method. The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.  
  
 Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread will be blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter. If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example receives a message from a queue and outputs information about that message to the screen. The example pauses execution for up to five seconds while waiting for a message to arrive in the queue.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive in the queue before the time-out expired.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</param>
        <summary>Receives the current message in the queue, using a specified cursor. If no message is available, this method waits until either a message is available, or the time-out expires.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive in the queue before the time-out expired.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method  
  
 Use this overload to receive a message and return in a specified period of time if there are no messages in the queue.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the first message available in the transactional queue referenced by the <see cref="T:System.Messaging.MessageQueue" /> and waits until either a message is available in the queue, or the time-out expires.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to receive a message from a transactional queue using the internal transaction context defined by the `transaction` parameter, and return within a specified period of time if there are no messages in the queue.  
  
 The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue. Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue.  
  
 Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method. The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>. Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there would be nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread will be blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter. If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of this method.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive in the queue before the time-out expired.  
  
 -or-  
  
 The queue is non-transactional.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" />. This call is synchronous, and waits until either a message is available in the queue, or the time-out expires.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to receive a message from a queue using a transaction context defined by the `transactionType` parameter, and return in a specified period of time if there are no messages in the queue.  
  
 Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message. Specify `Single` if you want to receive the message as a single internal transaction. You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.  
  
 The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue. Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue.  
  
 If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method. The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>. Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there would be nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread will be blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter. If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of this method.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive in the queue before the time-out expired.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the current message in the queue, using a specified cursor. If no message is available, this method waits until either a message is available, or the time-out expires.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references a message in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to receive a message from a transactional queue using the internal transaction context defined by the `transaction` parameter, and return within a specified period of time if there are no messages in the queue.  
  
 The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue. Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> return the messages that follow in the queue.  
  
 Because this method is called on a transactional queue, the message that is received is returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 To read a message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>. Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there is nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread is blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter. If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="cursor" /> parameter is <see langword="null" />.  
  
 -or-  
  
 The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid. Possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive in the queue before the time-out expired.  
  
 -or-  
  
 The queue is non-transactional.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values that describes the type of transaction context to associate with the message.</param>
        <summary>Receives the current message in the queue, using a specified cursor. If no message is available, this method waits until either a message is available, or the time-out expires.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references a message in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to receive a message from a queue using a transaction context defined by the `transactionType` parameter, and return in a specified period of time if there are no messages in the queue.  
  
 Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message. Specify `Single` if you want to receive the message as a single internal transaction. You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.  
  
 The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue. Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> return the messages that follow in the queue.  
  
 If this method is called to receive a message from a transactional queue, the message that is received is returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 To read a message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>. Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there is nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread is blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter. If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="cursor" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid. Possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive in the queue before the time-out expired.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>The method is not thread safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Receives a message that matches a given correlation identifier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</param>
        <summary>Receives the message that matches the given correlation identifier (from a non-transactional queue) and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method looks in the non-transactional queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter. If no message is found that matches the `correlationID` parameter, an exception is thrown. Otherwise, the message is removed from the queue and returned to the application.  
  
 The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.  
  
 Two other methods allow you to receive messages from a queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method retrieves a message by specifying its unique identifier.  
  
 To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method. The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example sends and receives a message that contains an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="correlationId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the message that matches the given correlation identifier (from a transactional queue) and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method looks in the transactional queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter. If no message is found that matches the `correlationID` parameter, an exception is thrown. Otherwise, the message is removed from the queue and returned to the application using the internal transaction context defined by the `transaction` parameter.  
  
 Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.  
  
 Two other methods allow you to receive messages from a queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.  
  
 To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method. The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Because <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.  
  
 -or-  
  
 The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="correlationId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The queue is non-transactional.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Receives the message that matches the given correlation identifier and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method looks in the queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter. If no message is found that matches the `correlationID` parameter, an exception is thrown. Otherwise, the message is removed from the queue and returned to the application using a transaction context defined by the `transactionType` parameter.  
  
 Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message. Specify `Single` if you want to receive the message as a single internal transaction. You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.  
  
 If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.  
  
 Two other methods allow you to receive messages from a queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.  
  
 To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method. The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Because <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="correlationId" /> could not be found.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <summary>Receives the message that matches the given correlation identifier (from a non-transactional queue) and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method looks in the non-transactional queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter. This method returns immediately if the message with the correlation identifier specified by the `correlationId` parameter is in the queue. Otherwise, the method waits the given period of time for a new message to arrive. If a new message does not arrive before the time-out expires, an exception is thrown.  
  
 The `timeout` parameter does not specify the total running time for this method. Rather, it specifies the time to wait for a new message to arrive in the queue. Each time a new message arrives, this method examines the <xref:System.Messaging.Message.CorrelationId%2A> of the new message to see if it matches the `correlationId` parameter. If not, this method starts the time-out period over and waits for another new message to arrive. Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.CorrelationId%2A> matches the `correlationId` parameter.  
  
 The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.  
  
 Two other methods allow you to receive messages from a queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.  
  
 To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method. The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the message that matches the given correlation identifier (from a transactional queue) and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method looks in the transactional queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter. This method returns immediately if the message with the correlation identifier specified by the `correlationId` parameter is in the queue, using the internal transaction context defined by the `transaction` parameter. Otherwise, the method waits the given period of time for a new message to arrive. If a new message does not arrive before the time-out expires, an exception is thrown.  
  
 The `timeout` parameter does not specify the total running time for this method. Rather, it specifies the time to wait for a new message to arrive in the queue. Each time a new message arrives, this method examines the <xref:System.Messaging.Message.CorrelationId%2A> of the new message to see if it matches the `correlationId` parameter. If not, this method starts the time-out period over and waits for another new message to arrive. Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.CorrelationId%2A> matches the `correlationId` parameter.  
  
 Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.  
  
 Two other methods allow you to receive messages from a queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.  
  
 To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method. The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Because <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.  
  
 -or-  
  
 The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.  
  
 -or-  
  
 The queue is non-transactional.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Receives the message that matches the given correlation identifier and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method looks in the queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter. This method returns immediately if the message with the correlation identifier specified by the `correlationId` parameter is in the queue, using a transaction context defined by the `transactionType` parameter. Otherwise, the method waits the given period of time for a new message to arrive. If a new message does not arrive before the time-out expires, an exception is thrown.  
  
 The `timeout` parameter does not specify the total running time for this method. Rather, it specifies the time to wait for a new message to arrive in the queue. Each time a new message arrives, this method examines the <xref:System.Messaging.Message.CorrelationId%2A> of the new message to see if it matches the `correlationId` parameter. If not, this method starts the time-out period over and waits for another new message to arrive. Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.CorrelationId%2A> matches the `correlationId` parameter. Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message. Specify `Single` if you want to receive the message as a single internal transaction. You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.  
  
 If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.  
  
 Two other methods allow you to receive messages from a queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.  
  
 To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method. The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Because <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="correlationId" /> could not be found.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Receives the message that matches the given identifier, removing it from the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</param>
        <summary>Receives the message that matches the given identifier from a non-transactional queue and immediately raises an exception if no message with the specified identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to read a message with a known identifier and remove it from the queue. This method throws an exception immediately if the message is not in the queue.  
  
 The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.  
  
 Two other methods allow you to receive messages from a queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.  
  
 To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method. The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="id" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the message that matches the given identifier (from a transactional queue) and immediately raises an exception if no message with the specified identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to read a message with a known identifier and remove it from the queue, using the internal transaction context defined by the `transaction` parameter. This method throws an exception immediately if the message is not in the queue  
  
 The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.  
  
 Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 Two other methods allow you to receive messages from a queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.  
  
 To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method. The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Because <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.  
  
 -or-  
  
 The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="id" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The queue is non-transactional.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Receives the message that matches the given identifier and immediately raises an exception if no message with the specified identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to read a message with a known identifier and remove it from the queue. This method throws an exception immediately if the message is not in the queue. Otherwise, the message is removed from the queue and returned to the application using a transaction context defined by the `transactionType` parameter.  
  
 Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message. Specify `Single` if you want to receive the message as a single internal transaction. You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.  
  
 The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter. If the message with the specified identifier is in a queue other than the one associated with this <xref:System.Messaging.MessageQueue> instance, the message will not be found.  
  
 If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 Two other methods allow you to receive messages from a queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.  
  
 To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method. The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Because <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="id" /> could not be found.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <summary>Receives the message that matches the given identifier (from a non-transactional queue) and waits until either a message with the specified identifier is available in the queue or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to read a message with a known identifier and remove it from the queue. This method returns immediately if the message with the identifier specified by the `id` parameter is in the queue. Otherwise, the method waits the given period of time for a new message to arrive. If a new message does not arrive before the time-out expires, an exception is thrown.  
  
 The `timeout` parameter does not specify the total running time for this method. Rather, it specifies the time to wait for a new message to arrive in the queue. Each time a new message arrives, this method examines the <xref:System.Messaging.Message.Id%2A> of the new message to see if it matches the `id` parameter. If not, this method starts the time-out period over and waits for another new message to arrive. Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.Id%2A> matches the `id` parameter.  
  
 The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.  
  
 Use this overload of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> when it is acceptable for the current thread to be blocked as long as new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter. The thread will be blocked for at least the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter, or if new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter.  
  
 Two other methods allow you to receive messages from a queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.  
  
 To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method. The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message with the specified <paramref name="id" /> did not arrive in the queue before the time-out expired.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the message that matches the given identifier (from a transactional queue) and waits until either a message with the specified identifier is available in the queue or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to read a message with a known identifier and remove it from the queue, using the internal transaction context defined by the `transaction` parameter. This method returns immediately if the message with the identifier specified by the `id` parameter is in the queue. Otherwise, the method waits the given period of time for a new message to arrive. If a new message does not arrive before the time-out expires, an exception is thrown.  
  
 The `timeout` parameter does not specify the total running time for this method. Rather, it specifies the time to wait for a new message to arrive in the queue. Each time a new message arrives, this method examines the <xref:System.Messaging.Message.Id%2A> of the new message to see if it matches the `id` parameter. If not, this method starts the time-out period over and waits for another new message to arrive. Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.Id%2A> matches the `id` parameter.  
  
 The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.  
  
 Use this overload of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> when it is acceptable for the current thread to be blocked as long as new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter. The thread will be blocked for at least the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter, or if new messages continue to arrive in the queue within the timeout period specified by the `timeout` parameter.  
  
 Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 Two other methods allow you to receive messages from a queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.  
  
 To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method. The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message, unless a higher priority message arrives in the queue. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Because <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.  
  
 -or-  
  
 The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message with the specified <paramref name="id" /> did not arrive in the queue before the time-out expired.  
  
 -or-  
  
 The queue is non-transactional.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Receives the message that matches the given identifier and waits until either a message with the specified identifier is available in the queue or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to read a message with a known identifier and remove it from the queue. This method returns immediately if the message with the identifier specified by the `id` parameter is in the queue, using a transaction context defined by the `transactionType` parameter. Otherwise, the method waits the given period of time for a new message to arrive. If a new message does not arrive before the time-out expires, an exception is thrown.  
  
 The `timeout` parameter does not specify the total running time for this method. Rather, it specifies the time to wait for a new message to arrive in the queue. Each time a new message arrives, this method examines the <xref:System.Messaging.Message.Id%2A> of the new message to see if it matches the `id` parameter. If not, this method starts the time-out period over and waits for another new message to arrive. Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.Id%2A> matches the `id` parameter.  
  
 Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message. Specify `Single` if you want to receive the message as a single internal transaction. You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.  
  
 The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter. If the message with the specified identifier is in a queue other than the one associated with this <xref:System.Messaging.MessageQueue> instance, the message will not be found.  
  
 Use this overload of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> when it is acceptable for the current thread to be blocked as long as new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter. The thread will be blocked for at least the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter, or if new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter.  
  
 If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 Two other methods allow you to receive messages from a queue. The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.  
  
 To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method. The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Because <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message with the specified <paramref name="id" /> did not arrive in the queue before the time-out expired.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Introduced in MSMQ 3.0. Receives a specific message from the queue. The message can be specified by a lookup identifier or by its position at the front or end of the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to receive.</param>
        <summary>Introduced in MSMQ 3.0. Receives the message that matches the given lookup identifier from a non-transactional queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.LookupId" /> property matches the <paramref name="lookupId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to read a message with a known lookup identifier and remove it from the queue. This method throws an exception immediately if the message is not in the queue.  
  
 The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.  
  
 To read a message with a specified lookup identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> method.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="lookupId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">One of the <see cref="T:System.Messaging.MessageLookupAction" /> values, specifying how the message is read in the queue. Specify one of the following:  
  
 <see langword="MessageLookupAction.Current" />: Receives the message specified by <paramref name="lookupId" /> and removes it from the queue.  
  
 <see langword="MessageLookupAction.Next" />: Receives the message following the message specified by <paramref name="lookupId" /> and removes it from the queue.  
  
 <see langword="MessageLookupAction.Previous" />: Receives the message preceding the message specified by <paramref name="lookupId" /> and removes it from the queue.  
  
 <see langword="MessageLookupAction.First" />: Receives the first message in the queue and removes it from the queue. The <paramref name="lookupId" /> parameter must be set to 0.  
  
 <see langword="MessageLookupAction.Last" />: Receives the last message in the queue and removes it from the queue. The <paramref name="lookupId" /> parameter must be set to 0.</param>
        <param name="lookupId">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to receive, or 0. 0 is used when accessing the first or last message in the queue.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Introduced in MSMQ 3.0. Receives a specific message from a transactional queue. The message can be specified by a lookup identifier or by its position at the front or end of the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> specified by the <paramref name="lookupId" /> and <paramref name="action" /> parameters passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to read a message with a known lookup identifier and remove it from the queue, using a transaction context defined by the `transaction` parameter. This method throws an exception immediately if the message is not in the queue.  
  
 The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.  
  
 Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> method. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Because <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> does not remove any messages from the queue, there would be nothing to roll back if the transaction were aborted.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="lookupId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.  
  
 -or-  
  
 The queue is non-transactional.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="action" /> parameter is not one of the <see cref="T:System.Messaging.MessageLookupAction" /> members.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">One of the <see cref="T:System.Messaging.MessageLookupAction" /> values, specifying how the message is read in the queue. Specify one of the following:  
  
 <see langword="MessageLookupAction.Current" />: Receives the message specified by <paramref name="lookupId" /> and removes it from the queue.  
  
 <see langword="MessageLookupAction.Next" />: Receives the message following the message specified by <paramref name="lookupId" /> and removes it from the queue.  
  
 <see langword="MessageLookupAction.Previous" />: Receives the message preceding the message specified by <paramref name="lookupId" /> and removes it from the queue.  
  
 <see langword="MessageLookupAction.First" />: Receives the first message in the queue and removes it from the queue. The <paramref name="lookupId" /> parameter must be set to 0.  
  
 <see langword="MessageLookupAction.Last" />: Receives the last message in the queue and removes it from the queue. The <paramref name="lookupId" /> parameter must be set to 0.</param>
        <param name="lookupId">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to receive, or 0. 0 is used when accessing the first or last message in the queue.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Introduced in MSMQ 3.0. Receives a specific message from the queue, using the specified transaction context. The message can be specified by a lookup identifier or by its position at the front or end of the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> specified by the <paramref name="action" /> and <paramref name="lookupId" /> parameters passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to read a message with a known lookup identifier and remove it from the queue, using a transaction context defined by the `transactionType` parameter. This method throws an exception immediately if the message is not in the queue.  
  
 The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.  
  
 To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> method. There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Because <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> does not remove any messages from the queue, there would be nothing to roll back if the transaction were aborted.  
  
 Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message. Specify `Single` if you want to receive the message as a single internal transaction. You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.  
  
 If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from the queue until the transaction is committed.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="lookupId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="action" /> parameter is not one of the <see cref="T:System.Messaging.MessageLookupAction" /> members.  
  
 -or-  
  
 The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a message has been removed from the queue. This event is raised by the asynchronous operation, <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> is used in asynchronous processing to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event when a message is available in the queue.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is used to complete the operation initiated by a call to <xref:System.Messaging.MessageQueue.BeginReceive%2A> and peek the message when the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised.  
  
 When you create a <xref:System.Messaging.ReceiveCompletedEventHandler> delegate, you identify the method that will handle the event. To associate the event with your event handler, add an instance of the delegate to the event. The event handler is called whenever the event occurs, unless you remove the delegate. For more information about event handler delegates, see [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 The following code example creates an event handler named `MyReceiveCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginReceive%2A> to initiate an asynchronous receive operation on the queue that is located at the path ".\myQueue". When a <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, the example receives the message and writes its body to the screen. The example then calls <xref:System.Messaging.MessageQueue.BeginReceive%2A> again to initiate a new asynchronous receive operation.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Refreshes the properties presented by the <see cref="T:System.Messaging.MessageQueue" /> to reflect the current state of the resource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> synchronizes the properties of a <xref:System.Messaging.MessageQueue> with its associated Message Queuing server resource. If any property, such as <xref:System.Messaging.MessageQueue.Label%2A> or <xref:System.Messaging.MessageQueue.Category%2A>, has changed on the server since the time the <xref:System.Messaging.MessageQueue> was created, <xref:System.Messaging.MessageQueue.Refresh%2A> updates the <xref:System.Messaging.MessageQueue> with the new information.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the permission list to the operating system's default values. Removes any queue permissions you have appended to the default list.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When you call <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, you return the permission list to its default values. Generally, this grants the queue creator all permissions, and gives the group Everyone the following rights:  
  
-   Get the properties of the queue.  
  
-   Get queue permissions.  
  
-   Write to the queue.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sends an object to a queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object to send to the queue.</param>
        <summary>Sends an object to non-transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to send a message that contains the `obj` parameter to the queue referenced by the <xref:System.Messaging.MessageQueue>. The object you send to the queue can be a <xref:System.Messaging.Message> or any managed object. If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.  
  
 If you use this overload to send a message to a transactional queue, the message will be sent to the dead-letter queue. If you want the message to be part of a transaction that contains other messages, use an overload that takes a <xref:System.Messaging.MessageQueueTransaction> or <xref:System.Messaging.MessageQueueTransactionType> as a parameter.  
  
 If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.  
  
 The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>. If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue. When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example connects to a message queue and sends a message to the queue.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 The following code example sends an application-defined `Order` class to a queue and then receives a message from that queue.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">The object to send to the queue.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Sends an object to the transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to send a message that contains the `obj` parameter to the transactional queue referenced by the <xref:System.Messaging.MessageQueue>, using an internal transaction context defined by the `transaction` parameter. The object you send to the queue can be a <xref:System.Messaging.Message> or any managed object. If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.  
  
 If you use this overload to send a message to a non-transactional queue, the message might be sent to the dead-letter queue without throwing an exception.  
  
 If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.  
  
 The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>. If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue. When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.  
  
 <xref:System.Messaging.MessageQueueTransaction> is threading apartment aware, so if your apartment state is `STA`, you cannot use the transaction in multiple threads. Visual Basic sets the state of the main thread to `STA`, so you must apply the <xref:System.MTAThreadAttribute> in the `Main` subroutine. Otherwise, sending a transactional message using another thread throws a <xref:System.Messaging.MessageQueueException> exception. You apply the <xref:System.MTAThreadAttribute> by using the following fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example sends a string to a transactional queue and then receives a message from that queue.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.  
  
 -or-  
  
 The Message Queuing application indicated an incorrect transaction use.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">The object to send to the queue.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Sends an object to the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to send a message that contains the `obj` parameter to the queue referenced by the <xref:System.Messaging.MessageQueue>, using a transaction context defined by the `transactionType` parameter. Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to send the message. Specify `Single` if you want to send the message as a single internal transaction. You can specify `None` if you want to send a transactional message to a non-transactional thread.  
  
 The object you send to the queue can be a <xref:System.Messaging.Message> or any managed object. If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.  
  
 If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.  
  
 The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>. If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue. When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">The object to send to the queue.</param>
        <param name="label">The label of the message.</param>
        <summary>Sends an object to the non-transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> and specifies a label for the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to send a message that contains the `obj` parameter to the queue referenced by the <xref:System.Messaging.MessageQueue>. With this overload, you can specify the string label that identifies the message. The object you send to the queue can be a <xref:System.Messaging.Message>, a structure, a data object, or any managed object. If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.  
  
 The message label is distinct from the message queue label, but both are application-dependent and have no inherit meaning to Message Queuing.  
  
 If you use this overload to send a message to a transactional queue, the message will be sent to the dead-letter queue. If you want the message to be part of a transaction that contains other messages, use an overload that takes a <xref:System.Messaging.MessageQueueTransaction> or <xref:System.Messaging.MessageQueueTransactionType> as a parameter.  
  
 The <xref:System.Messaging.MessageQueue.Path%2A> property for this <xref:System.Messaging.MessageQueue> instance must be specified before you send the message. If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.  
  
 The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>. If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue. When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="label" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">The object to send to the queue.</param>
        <param name="label">The label of the message.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Sends an object to the transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> and specifies a label for the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to send a message that contains the `obj` parameter to the transactional queue referenced by the <xref:System.Messaging.MessageQueue>, using an internal transaction context defined by the `transaction` parameter. With this overload, you can specify the string label that identifies the message. The object you send to the queue can be a <xref:System.Messaging.Message>, a structure, a data object, or any managed object. If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.  
  
 The message label is distinct from the message queue label, but both are application-dependent and have no inherit meaning to Message Queuing.  
  
 If you use this overload to send a message to a non-transactional queue, the message might be sent to the dead-letter queue without throwing an exception.  
  
 If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.  
  
 The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>. If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue. When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property  
  
 <xref:System.Messaging.MessageQueueTransaction> is threading apartment aware, so if your apartment state is `STA`, you cannot use the transaction in multiple threads. Visual Basic sets the state of the main thread to `STA`, so you must apply the <xref:System.MTAThreadAttribute> in the `Main` subroutine. Otherwise, sending a transactional message using another thread throws a <xref:System.Messaging.MessageQueueException> exception. You apply the <xref:System.MTAThreadAttribute> by using the following fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="label" /> parameter is <see langword="null" />.  
  
 -or-  
  
 The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.  
  
 -or-  
  
 The Message Queuing application indicated an incorrect transaction usage.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">The object to send to the queue.</param>
        <param name="label">The label of the message.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Sends an object to the queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> and specifies a label for the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to send a message that contains the `obj` parameter to the queue referenced by the <xref:System.Messaging.MessageQueue>, using a transaction context defined by the `transactionType` parameter. Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to send the message. Specify `Single` if you want to send the message as a single internal transaction. You can specify `None` if you want to send a transactional message to a non-transactional thread.  
  
 The object you send to the queue can be a <xref:System.Messaging.Message> or any managed object. If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message. With this overload, you can specify the string label that identifies the message.  
  
 The message label is distinct from the message queue label, but both are application-dependent and have no inherit meaning to Message Queuing.  
  
 If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.  
  
 The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>. If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue. When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="label" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">The Message Queuing application indicated an incorrect transaction usage.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.  
  
 -or-  
  
 An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds permissions to the current set. This controls who has access rights to queue properties and messages in the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">A <see cref="T:System.Messaging.AccessControlList" /> that contains one or more access control entries that specify the trustees and the permissions to grant.</param>
        <summary>Assigns access rights to the queue based on the contents of an access control list.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to grant, deny, or revoke rights by using a collection of access control entries to specify trustee and permissions information. This is used, for example, to grant permissions to multiple users at the same time.  
  
 The trustee you specify when you construct the `ace` parameter can be an individual user, a group of users, or a computer. If the trustee is an individual, use the format `DOMAIN`\\`user`. You can specify "." for the trustee to indicate the local computer.  
  
 The permissions you assign through <xref:System.Messaging.MessageQueue.SetPermissions%2A> add rights to the existing list. By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue. When you call <xref:System.Messaging.MessageQueue.SetPermissions%2A>, the user and permissions information is appended to the bottom of the existing list.  
  
 The system examines each <xref:System.Messaging.AccessControlEntry> in sequence until one of the following events occurs:  
  
-   An access-denied <xref:System.Messaging.AccessControlEntry> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.  
  
-   One or more access-allowed <xref:System.Messaging.AccessControlEntry> items for trustees listed in the thread's access token explicitly grant all the requested access rights.  
  
-   All <xref:System.Messaging.AccessControlEntry> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.  
  
 When you construct the `dacl` parameter, you add <xref:System.Messaging.AccessControlEntry> instances to your <xref:System.Messaging.AccessControlList> collection. When you construct each access control entry, you can specify generic or standard access rights. The rights to a queue can be any combination of the following:  
  
-   Delete  
  
-   Read Security  
  
-   Write Security  
  
-   Synchronize  
  
-   Modify Owner  
  
-   Read  
  
-   Write  
  
-   Execute  
  
-   Required  
  
-   All  
  
-   None  
  
 These rights are a set of bit flags that you can combine using the OR bitwise operator.  
  
-   Full Control  
  
-   Delete Message  
  
-   Receive Message  
  
-   Peek Message  
  
-   Receive Journal Message  
  
-   Get Queue Properties  
  
-   Set Queue Properties  
  
-   Get Permissions  
  
-   Set Permissions  
  
-   Take Queue Ownership  
  
-   Write Message  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">A <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> that specifies a user, an access type, and a permission type.</param>
        <summary>Assigns access rights to the queue based on the contents of an access control entry.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to grant, deny, or revoke rights by using an access control entry to specify trustee and rights information.  
  
 The trustee you specify when you construct the `ace` parameter can be an individual user, a group of users, or a computer. If the trustee is an individual, use the format `DOMAIN`\\`user`. You can specify "." for the trustee to indicate the local computer.  
  
 The permissions you assign through <xref:System.Messaging.MessageQueue.SetPermissions%2A> add rights to the existing list. By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue. When you call <xref:System.Messaging.MessageQueue.SetPermissions%2A>, the user and permissions information is appended to the bottom of the existing list.  
  
 The system examines each <xref:System.Messaging.AccessControlEntry> in sequence until one of the following events occurs:  
  
-   An access-denied <xref:System.Messaging.AccessControlEntry> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.  
  
-   One or more access-allowed <xref:System.Messaging.AccessControlEntry> items for trustees listed in the thread's access token explicitly grant all the requested access rights.  
  
-   All <xref:System.Messaging.AccessControlEntry> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.  
  
 The rights to a queue, which you specify in the `rights` parameter when you construct your <xref:System.Messaging.MessageQueueAccessControlEntry>, can be any combination of the following:  
  
-   Full Control  
  
-   Delete Message  
  
-   Receive Message  
  
-   Peek Message  
  
-   Receive Journal Message  
  
-   Get Queue Properties  
  
-   Set Queue Properties  
  
-   Get Permissions  
  
-   Set Permissions  
  
-   Take Queue Ownership  
  
-   Write Message  
  
 The `rights` parameter you specify in the constructor for the `ace` parameter is a flag of the <xref:System.Messaging.MessageQueueAccessRights> enumeration. It represents a set of bit flags that you can combine using the bitwise operator OR when you build the `rights` parameter.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">The individual, group, or computer that gets additional rights to the queue.</param>
        <param name="rights">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> that indicates the set of rights to the queue that Message Queuing assigns to the <paramref name="user" /> passed in.</param>
        <summary>Gives a computer, group, or user the specified access rights.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to grant specified rights to an individual user. The user can be any valid trustee, which includes individual users, groups of users, or a computer. If the user is an individual, use the format `DOMAIN`\\`user` for the `user` parameter. You can specify "." for the `user` parameter to indicate the local computer.  
  
 The permissions you assign through <xref:System.Messaging.MessageQueue.SetPermissions%2A> add rights to the existing list. By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue. When you call <xref:System.Messaging.MessageQueue.SetPermissions%2A>, the user and permissions information is appended to the bottom of the existing list.  
  
 The system examines each <xref:System.Messaging.AccessControlEntry> in sequence until one of the following events occurs:  
  
-   An access-denied <xref:System.Messaging.AccessControlEntry> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.  
  
-   One or more access-allowed <xref:System.Messaging.AccessControlEntry> items for trustees listed in the thread's access token explicitly grant all the requested access rights.  
  
-   All <xref:System.Messaging.AccessControlEntry> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.  
  
 The rights to a queue, specified in the `rights` parameter, can be any combination of the following:  
  
-   Full Control  
  
-   Delete Message  
  
-   Receive Message  
  
-   Peek Message  
  
-   Receive Journal Message  
  
-   Get Queue Properties  
  
-   Set Queue Properties  
  
-   Get Permissions  
  
-   Set Permissions  
  
-   Take Queue Ownership  
  
-   Write Message  
  
 The <xref:System.Messaging.MessageQueueAccessRights> enumeration represents a set of bit flags that you can combine using the bitwise operator OR to build the `rights` parameter.  
  
 With this overload, you can only grant permissions; you cannot revoke or deny them. You must use a different overload to explicitly grant any <xref:System.Messaging.AccessControlEntryType> other than `Allow`.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="user" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">The individual, group, or computer that gets additional rights to the queue.</param>
        <param name="rights">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> that indicates the set of rights to the queue that Message Queuing assigns to the <paramref name="user" /> passed in.</param>
        <param name="entryType">A <see cref="T:System.Messaging.AccessControlEntryType" /> that specifies whether to grant, deny, or revoke the permissions specified by the <paramref name="rights" /> parameter.</param>
        <summary>Gives a computer, group, or user the specified access rights, with the specified access control type (allow, deny, revoke, or set).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this overload to grant, deny, or revoke specified rights for an individual user. The user can be any valid trustee, which includes individual users, groups of users, or a computer. If the user is an individual, use the format `DOMAIN`\\`user` for the `user` parameter. You can specify "." for the `user` parameter to indicate the local computer.  
  
 The permissions you assign through <xref:System.Messaging.MessageQueue.SetPermissions%2A> add rights to the existing list. By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue. When you call <xref:System.Messaging.MessageQueue.SetPermissions%2A>, the user and permissions information is appended to the bottom of the existing list.  
  
 The system examines each <xref:System.Messaging.AccessControlEntry> in sequence until one of the following events occurs:  
  
-   An access-denied <xref:System.Messaging.AccessControlEntry> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.  
  
-   One or more access-allowed <xref:System.Messaging.AccessControlEntry> items for trustees listed in the thread's access token explicitly grant all the requested access rights.  
  
-   All <xref:System.Messaging.AccessControlEntry> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.  
  
 The rights to a queue, specified in the `rights` parameter, can be any combination of the following:  
  
-   Full Control  
  
-   Delete Message  
  
-   Receive Message  
  
-   Peek Message  
  
-   Receive Journal Message  
  
-   Get Queue Properties  
  
-   Set Queue Properties  
  
-   Get Permissions  
  
-   Set Permissions  
  
-   Take Queue Ownership  
  
-   Write Message  
  
 The <xref:System.Messaging.MessageQueueAccessRights> enumeration represents a set of bit flags that you can combine using the bitwise operator OR to build the `rights` parameter.  
  
 The following table shows whether this method is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object that marshals the event-handler call resulting from a <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> or <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> event.</summary>
        <value>A <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, which represents the object that marshals the event-handler call resulting from a <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> or <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> event. The default is <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Messaging.MessageQueue.ReceiveCompleted> or <xref:System.Messaging.MessageQueue.PeekCompleted> event results from a <xref:System.Messaging.MessageQueue.BeginReceive%2A> or <xref:System.Messaging.MessageQueue.BeginPeek%2A> request, respectively, to a specific thread. Typically, the <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> is set when its related component is placed inside a control or a form, because those components are bound to a specific thread.  
  
 Typically, the synchronizing object marshals a method call into a single thread.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the queue accepts only transactions.</summary>
        <value>
          <see langword="true" /> if the queue accepts only messages sent as part of a transaction; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transactional messaging refers to the coupling of several related messages into a single transaction. Sending messages as part of a transaction ensures that the messages are delivered in order, delivered only once, and successfully retrieved from their destination queue.  
  
 If a queue is transactional, it accepts only messages that are sent as part of a transaction. However, a non-transactional message can be sent or received from a local transaction queue without explicitly using transactional <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, and <xref:System.Messaging.MessageQueueTransaction.Abort%2A> syntax. If a non-transactional message is sent to a transactional queue, this component creates a single-message transaction for it, except in the case of referencing a queue on a remote computer using a direct format name. In this situation, if you do not specify a transaction context when sending a message, one is not created for you and the message will be sent to the dead-letter queue.  
  
 If you send a non-transactional message to a transactional queue, you will not be able to roll back the message in the event of an exception.  
  
 <xref:System.Messaging.MessageQueueTransaction> is threading apartment aware, so if your apartment state is `STA`, you cannot use the transaction in multiple threads. Visual Basic sets the state of the main thread to `STA`, so you must apply the <xref:System.MTAThreadAttribute> in the `Main` subroutine. Otherwise, sending a transactional message using another thread throws a <xref:System.Messaging.MessageQueueException> exception. You apply the <xref:System.MTAThreadAttribute> by using the following fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.Transactional%2A> property.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether received messages are copied to the journal queue.</summary>
        <value>
          <see langword="true" /> if messages received from the queue are copied to its journal queue; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When the Message Queuing application creates a new application queue, it automatically creates an associated journal queue in the same location. The journal queue is used to track the messages removed from a queue. Setting this property modifies the Message Queuing queue. Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change.  
  
 The journal queue does not track messages removed from the queue because their time-to-be-received timer expired, nor does it track messages purged from the queue by using a Message Queuing directory service (Information Store or Active Directory).  
  
 Applications cannot send messages to journal queues; they are limited to read-only access of these queues. Furthermore, Message Queuing never removes messages from journal queues. The application using the queue must clear these messages either by receiving them or by purging the queue.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|No|  
  
   
  
## Examples  
 The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> property.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle used to send messages to the message queue.</summary>
        <value>A handle to the native queue object that you use for sending messages to the queue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Messaging.MessageQueue.WriteHandle%2A> provides a native Windows handle to the message queue object that is used for sending messages to the queue. If you change the path of the queue, the handle is closed and reopened with a new value.  
  
 The following table shows whether this property is available in various Workgroup modes.  
  
|Workgroup mode|Available|  
|--------------------|---------------|  
|Local computer|Yes|  
|Local computer and direct format name|Yes|  
|Remote computer|No|  
|Remote computer and direct format name|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">The message queue is not available for writing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>