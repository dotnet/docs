<Type Name="UnmanagedMarshal" FullName="System.Reflection.Emit.UnmanagedMarshal">
  <TypeSignature Language="C#" Value="public sealed class UnmanagedMarshal" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit UnmanagedMarshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.UnmanagedMarshal" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents the class that describes how to marshal a field from managed to unmanaged code. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The code example shows the workaround for this obsolete type.  
  
 Marshaling is the process of packaging and unpackaging parameters so remote procedure calls can occur. During marshaling, a field might undergo a format conversion when the format of the managed type is different from the format of the corresponding unmanaged type. For example, you might want to marshal a `String` type as an unmanaged BSTR. Some format conversions are handled automatically by the runtime. To override the default behavior, you must use the `UnmanagedMarshal` class to define the format conversion.  
  
   
  
## Examples  
 The following code example shows replacement code for the obsolete <xref:System.Reflection.Emit.UnmanagedMarshal> type. The example emits a single-module assembly named `EmitMarshalAs.dll`, containing a type named `Sample`. The type has a method named `Test`, with one parameter of type <xref:System.String>. The code example applies the <xref:System.Runtime.InteropServices.MarshalAsAttribute> with <xref:System.Runtime.InteropServices.UnmanagedType?displayProperty=fullName> to the parameter.  
  
 You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the emitted assembly and observe that the parameter is marked `marshal(bstr)`.  
  
 [!code-cpp[UnmanagedMarshalObsolete#1](~/samples/snippets/cpp/VS_Snippets_CLR/UnmanagedMarshalObsolete/cpp/source.cpp#1)]
 [!code-csharp[UnmanagedMarshalObsolete#1](~/samples/snippets/csharp/VS_Snippets_CLR/UnmanagedMarshalObsolete/cs/source.cs#1)]
 [!code-vb[UnmanagedMarshalObsolete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/UnmanagedMarshalObsolete/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.UnmanagedType BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.InteropServices.UnmanagedType BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.UnmanagedMarshal.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.UnmanagedType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an unmanaged base type. This property is read-only.</summary>
        <value>An <see langword="UnmanagedType" /> object.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The unmanaged type is not an <see langword="LPArray" /> or a <see langword="SafeArray" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineByValArray">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.UnmanagedMarshal DefineByValArray (int elemCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.UnmanagedMarshal DefineByValArray(int32 elemCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.UnmanagedMarshal.DefineByValArray(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.UnmanagedMarshal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elemCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elemCount">The number of elements in the fixed-length array.</param>
        <summary>Specifies a fixed-length array (ByValArray) to marshal to unmanaged code.</summary>
        <returns>An <see cref="T:System.Reflection.Emit.UnmanagedMarshal" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `DefineByValArray` method is not a simple native marshal.  
  
 Only unmanaged marshal constructs can be made using these static constructors.  
  
 Marshaling an array is a more complex process than marshaling an integer parameter. Array members are copied in a specific order so that the other side can reconstruct the array exactly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The argument is not a simple native type.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineByValTStr">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.UnmanagedMarshal DefineByValTStr (int elemCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.UnmanagedMarshal DefineByValTStr(int32 elemCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.UnmanagedMarshal.DefineByValTStr(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.UnmanagedMarshal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elemCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elemCount">The number of elements in the fixed array buffer.</param>
        <summary>Specifies a string in a fixed array buffer (ByValTStr) to marshal to unmanaged code.</summary>
        <returns>An <see cref="T:System.Reflection.Emit.UnmanagedMarshal" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `DefineByValStr` method is not a simple native marshal.  
  
 Only unmanaged marshal constructs can be made using these static constructors.  
  
 Marshaling an array is a more complex process than marshaling an integer parameter. Array members are copied in a specific order so that the other side can reconstruct the array exactly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The argument is not a simple native type.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineLPArray">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.UnmanagedMarshal DefineLPArray (System.Runtime.InteropServices.UnmanagedType elemType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.UnmanagedMarshal DefineLPArray(valuetype System.Runtime.InteropServices.UnmanagedType elemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.UnmanagedMarshal.DefineLPArray(System.Runtime.InteropServices.UnmanagedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.UnmanagedMarshal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elemType" Type="System.Runtime.InteropServices.UnmanagedType" />
      </Parameters>
      <Docs>
        <param name="elemType">The unmanaged type to which to marshal the array.</param>
        <summary>Specifies an <see langword="LPArray" /> to marshal to unmanaged code. The length of an <see langword="LPArray" /> is determined at runtime by the size of the actual marshaled array.</summary>
        <returns>An <see cref="T:System.Reflection.Emit.UnmanagedMarshal" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `DefineLPArray` method is not a simple native marshal.  
  
 Only unmanaged marshal constructs can be made using these static constructors.  
  
 Marshaling an array is a more complex process than marshaling an integer parameter. Array members are copied in a specific order so that the other side can reconstruct the array exactly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The argument is not a simple native type.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineSafeArray">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.UnmanagedMarshal DefineSafeArray (System.Runtime.InteropServices.UnmanagedType elemType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.UnmanagedMarshal DefineSafeArray(valuetype System.Runtime.InteropServices.UnmanagedType elemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.UnmanagedMarshal.DefineSafeArray(System.Runtime.InteropServices.UnmanagedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.UnmanagedMarshal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elemType" Type="System.Runtime.InteropServices.UnmanagedType" />
      </Parameters>
      <Docs>
        <param name="elemType">The base type or the <see langword="UnmanagedType" /> of each element of the array.</param>
        <summary>Specifies a <see langword="SafeArray" /> to marshal to unmanaged code.</summary>
        <returns>An <see cref="T:System.Reflection.Emit.UnmanagedMarshal" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `DefineSafeArray` method is not a simple native marshal.  
  
 Only unmanaged marshal constructs can be made using these static constructors.  
  
 Marshaling an array is a more complex process than marshaling an integer parameter. Array members are copied in a specific order so that the other side can reconstruct the array exactly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The argument is not a simple native type.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedMarshal">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.UnmanagedMarshal DefineUnmanagedMarshal (System.Runtime.InteropServices.UnmanagedType unmanagedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.UnmanagedMarshal DefineUnmanagedMarshal(valuetype System.Runtime.InteropServices.UnmanagedType unmanagedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.UnmanagedMarshal.DefineUnmanagedMarshal(System.Runtime.InteropServices.UnmanagedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.UnmanagedMarshal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedType" Type="System.Runtime.InteropServices.UnmanagedType" />
      </Parameters>
      <Docs>
        <param name="unmanagedType">The unmanaged type to which the type is to be marshaled.</param>
        <summary>Specifies a given type that is to be marshaled to unmanaged code.</summary>
        <returns>An <see cref="T:System.Reflection.Emit.UnmanagedMarshal" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Runtime.InteropServices.UnmanagedType> passed to this method must be a simple native type. None of the following values may be used: <xref:System.Runtime.InteropServices.UnmanagedType?displayProperty=fullName>, <xref:System.Runtime.InteropServices.UnmanagedType?displayProperty=fullName>, <xref:System.Runtime.InteropServices.UnmanagedType?displayProperty=fullName>, <xref:System.Runtime.InteropServices.UnmanagedType?displayProperty=fullName>, or <xref:System.Runtime.InteropServices.UnmanagedType?displayProperty=fullName>.  
  
 Only unmanaged marshal constructs can be made using this method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The argument is not a simple native type.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementCount">
      <MemberSignature Language="C#" Value="public int ElementCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ElementCount" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.UnmanagedMarshal.ElementCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a number element. This property is read-only.</summary>
        <value>An integer indicating the element count.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 There is an `ElementCount` only if there is a `NativeTypeFixedArray`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The argument is not an unmanaged element count.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUnmanagedType">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.UnmanagedType GetUnmanagedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.InteropServices.UnmanagedType GetUnmanagedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.UnmanagedMarshal.GetUnmanagedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.UnmanagedType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates an unmanaged type. This property is read-only.</summary>
        <value>An <see cref="T:System.Runtime.InteropServices.UnmanagedType" /> object.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `GetUnmanagedType` property is an accessor function for the native type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IIDGuid">
      <MemberSignature Language="C#" Value="public Guid IIDGuid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid IIDGuid" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.UnmanagedMarshal.IIDGuid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a GUID. This property is read-only.</summary>
        <value>A <see cref="T:System.Guid" /> object.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This property always returns Guid.Empty. This property might be removed in a future release.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The argument is not a custom marshaler.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
