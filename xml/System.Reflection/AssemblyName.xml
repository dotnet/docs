<Type Name="AssemblyName" FullName="System.Reflection.AssemblyName">
  <TypeSignature Language="C#" Value="public sealed class AssemblyName : ICloneable, System.Runtime.InteropServices._AssemblyName, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit AssemblyName extends System.Object implements class System.ICloneable, class System.Runtime.InteropServices._AssemblyName, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.AssemblyName" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._AssemblyName</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._AssemblyName))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Describes an assembly's unique identity in full.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The AssemblyName object contains information about an assembly, which you can use to bind to that assembly. An assembly's identity consists of the following:  
  
-   Simple name.  
  
-   Version number.  
  
-   Cryptographic key pair.  
  
-   Supported culture.  
  
 The simple name is typically the file name for the manifest file without its extension. The key pair includes a public and private key, used to create strong-name signatures for assemblies.  
  
 All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  
  
|Delimiter|Meaning|  
|---------------|-------------|  
|Backslash (\\)|Escape character.|  
|Comma (,)|Precedes the assembly name.|  
|Plus sign (+)|Precedes a nested class.|  
  
 For example, the fully qualified name for a class might look like this:  
  
 ContainingClass+NestedClass,MyAssembly  
  
 A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".  
  
 This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.  
  
 A fully specified AssemblyName must have the name, culture, public key or public key token, major version, minor version, build number, and revision number parameters. The last four are packaged in the <xref:System.Version> type.  
  
 To create a simple name, create an AssemblyName object using the default constructor and set the <xref:System.Reflection.AssemblyName.Name%2A>. The other properties are optional.  
  
 To create a full strong name, create an AssemblyName object using the default constructor and set the <xref:System.Reflection.AssemblyName.Name%2A> and <xref:System.Reflection.AssemblyName.KeyPair%2A>. The other properties are optional. Use <xref:System.Reflection.AssemblyName.SetPublicKey%2A> and <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> to set the public key and the strong name. The strong name signing always uses the <xref:System.Security.Cryptography.SHA1> hash algorithm.  
  
 To ensure that the names are constructed correctly, use the following properties:  
  
-   <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>  
  
-   <xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=fullName>  
  
-   <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=fullName>  
  
 You can also get the name by using the `/l` option with the [Gacutil.exe (Global Assembly Cache Tool)](../Topic/Gacutil.exe%20\(Global%20Assembly%20Cache%20Tool\).md)  
  
 For a partially specified strong name, create an AssemblyName object using the default constructor and set the name and public key. An assembly created using such an AssemblyName can be signed later using the Assembly Linker (Al.exe).  
  
 It is possible to specify a public key and a <xref:System.Reflection.AssemblyName.KeyPair%2A> with inconsistent values. This can be useful in developer scenarios. In this case, the public key retrieved with <xref:System.Reflection.AssemblyName.GetPublicKey%2A> specifies the correct public key, while the <xref:System.Reflection.AssemblyName.KeyPair%2A> specifies the public and private keys used during development. When the runtime detects a mismatch between the <xref:System.Reflection.AssemblyName.KeyPair%2A> and the public key, it looks up in the registry the correct key that matches the public key.  
  
 The format of the display name of an AssemblyName is a comma-delimited Unicode string that begins with the name, as follows:  
  
 `Name <,Culture = CultureInfo> <,Version = Major.Minor.Build.Revision> <, StrongName> <,PublicKeyToken> '\0'`  
  
 `Name` is the textual name of the assembly. `CultureInfo` is the RFC1766-format-defined culture. `Major`, `Minor`, `Build`, and `Revision` are the major version, minor version, build number, and revision number of the assembly. `StrongName` is the hexadecimal-encoded low-order 64 bits of the hash value of the public key generated using the SHA-1 hashing algorithm and the public key specified by <xref:System.Reflection.AssemblyName.SetPublicKey%2A>. `PublicKeyToken` is the hexadecimal-encoded public key specified by <xref:System.Reflection.AssemblyName.SetPublicKey%2A>.  
  
 Hexadecimal encoding is defined as the conversion of each byte of a binary object to two hexadecimal characters, progressing from least to most significant byte. Additional display values will be added as deemed necessary.  
  
 If the full public key is known, then PublicKey may be substituted for StrongName.  
  
 Also note that except for `Name`, which must come first, the lexical order of parameters is unimportant. However, any parameter (`Version`, `Culture`, `StrongName` or `PublicKey`) not specifically set is considered to be omitted, and the AssemblyName is then considered partial. When specifying partial information, Name parameters must be specified in the order described above.  
  
 When supplying a display name, the convention `StrongName =null` or `PublicKey= null` indicates that binding and matching against a simply named assembly is required. Additionally, the convention `Culture= ""` (double quote representing an empty string) indicates matching against the default culture.  
  
 The following example shows an AssemblyName for a simply named assembly with default culture.  
  
```  
ExampleAssembly, Culture=""  
```  
  
 The following example shows a fully specified reference for a strongly named assembly with culture "en".  
  
```  
ExampleAssembly, Version=1.0.0.0, Culture=en, PublicKeyToken=a5d015c7d5a0b012  
```  
  
   
  
## Examples  
 This example shows how to use various reflection classes to analyze the metadata contained in an assembly.  
  
 [!code-vb[Reflection#1](~/add/codesnippet/visualbasic/t-system.reflection.asse_3_1.vb)]
 [!code-cpp[Reflection#1](~/add/codesnippet/cpp/t-system.reflection.asse_3_1.cpp)]
 [!code-cs[Reflection#1](~/add/codesnippet/csharp/t-system.reflection.asse_3_1.cs)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Reflection.AssemblyName" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example creates a dynamic assembly named `MyAssembly.exe` and saves it to your hard disk. After running the example, you can use the [Ildasm.exe (IL Disassembler)](../Topic/Ildasm.exe%20\(IL%20Disassembler\).md) to examine the assembly metadata.  
  
 [!code-cpp[AssemblyName_Constructor#1](~/add/codesnippet/cpp/m-system.reflection.asse_9_1.cpp)]
 [!code-vb[AssemblyName_Constructor#1](~/add/codesnippet/visualbasic/m-system.reflection.asse_9_1.vb)]
 [!code-cs[AssemblyName_Constructor#1](~/add/codesnippet/csharp/m-system.reflection.asse_9_1.cs)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly, as returned by the <see cref="System.Reflection.AssemblyName.FullName%2A" /> property.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Reflection.AssemblyName" /> class with the specified display name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The supplied `assemblyName` is parsed, and the appropriate fields of the new <xref:System.Reflection.AssemblyName> are initialized with values from the display name. This is the recommended way of parsing display names. Writing your own code to parse display names is not recommended.  
  
   
  
## Examples  
 The following example creates an instance of <xref:System.Reflection.AssemblyName> from a display name. The individual elements of the display name are output to the console as properties of the <xref:System.Reflection.AssemblyName>object.  
  
 [!code-cpp[AssemblyName_Constructor_2#1](~/add/codesnippet/cpp/m-system.reflection.asse_3_1.cpp)]
 [!code-vb[AssemblyName_Constructor_2#1](~/add/codesnippet/visualbasic/m-system.reflection.asse_3_1.vb)]
 [!code-cs[AssemblyName_Constructor_2#1](~/add/codesnippet/csharp/m-system.reflection.asse_3_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> is a zero length string.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.  
  
</block>  
  
 The referenced assembly could not be found, or could not be loaded.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Makes a copy of this <see cref="T:System.Reflection.AssemblyName" /> object.</summary>
        <returns>An object that is a copy of this <see cref="T:System.Reflection.AssemblyName" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A new object is created, identical to the original.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public string CodeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the location of the assembly as a URL.</summary>
        <value>A string that is the URL location of the assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When an assembly is loaded, this value can also be obtained using the <xref:System.Reflection.Assembly.CodeBase%2A?displayProperty=fullName> property.  
  
 If the assembly was loaded as a byte array, this property returns the location of the caller of the [Load(Byte\<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%29> method overload, not the location of the loaded assembly.  
  
> [!NOTE]
>  Do not use an <xref:System.Reflection.AssemblyName> with only the CodeBase property set. The CodeBase property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method. Instead, the assembly is loaded using load-from rules. For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> method overload or [Best Practices for Assembly Loading](../Topic/Best%20Practices%20for%20Assembly%20Loading.md).  
  
   
  
## Examples  
 The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the CodeBase property is used to specify the directory where the assembly is saved.  
  
 [!code-cs[AssemblyName_CodeBase#1](~/add/codesnippet/csharp/p-system.reflection.asse_1_1.cs)]
 [!code-cpp[AssemblyName_CodeBase#1](~/add/codesnippet/cpp/p-system.reflection.asse_1_1.cpp)]
 [!code-vb[AssemblyName_CodeBase#1](~/add/codesnippet/visualbasic/p-system.reflection.asse_1_1.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public System.Reflection.AssemblyContentType ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.AssemblyContentType ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyContentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates what type of content the assembly contains.</summary>
        <value>A value that indicates what type of content the assembly contains.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CultureInfo">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CultureInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CultureInfo" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CultureInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the culture supported by the assembly.</summary>
        <value>An object that represents the culture supported by the assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the CultureInfo property is used to specify the culture, which is part of the assembly's display name.  
  
 [!code-cs[AssemblyName_CodeBase#2](~/add/codesnippet/csharp/p-system.reflection.asse_9_1.cs)]
 [!code-cpp[AssemblyName_CodeBase#2](~/add/codesnippet/cpp/p-system.reflection.asse_9_1.cpp)]
 [!code-vb[AssemblyName_CodeBase#2](~/add/codesnippet/visualbasic/p-system.reflection.asse_9_1.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CultureName">
      <MemberSignature Language="C#" Value="public string CultureName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CultureName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CultureName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the culture associated with the assembly.</summary>
        <value>The culture name.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the URI, including escape characters, that represents the codebase.</summary>
        <value>A URI with escape characters.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public System.Reflection.AssemblyNameFlags Flags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.AssemblyNameFlags Flags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyNameFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the attributes of the assembly.</summary>
        <value>A value that represents the attributes of the assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the Flags property is used to specify that the assembly has a public key.  
  
 [!code-vb[AssemblyName_KeyPair#4](~/add/codesnippet/visualbasic/p-system.reflection.asse_7_1.vb)]
 [!code-cs[AssemblyName_KeyPair#4](~/add/codesnippet/csharp/p-system.reflection.asse_7_1.cs)]
 [!code-cpp[AssemblyName_KeyPair#4](~/add/codesnippet/cpp/p-system.reflection.asse_7_1.cpp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the full name of the assembly, also known as the display name.</summary>
        <value>A string that is the full name of the assembly, also known as the display name.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The display name typically consists of the simple name, version number, supported culture, and public key. For example:  
  
```  
mylib, Version=1.2.1900.0, Culture=neutral, PublicKeyToken=a14f3033def15840  
```  
  
 Writing your own code to parse display names is not recommended. Instead, pass the display name to the <xref:System.Reflection.AssemblyName.%23ctor%2A> constructor, which parses it and populates the appropriate fields of the new <xref:System.Reflection.AssemblyName>.  
  
 When an assembly is loaded, this value can also be obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> property.  
  
   
  
## Examples  
 The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the code example sets the <xref:System.Reflection.AssemblyName.Name%2A>, <xref:System.Reflection.AssemblyName.Version%2A>, <xref:System.Reflection.AssemblyName.CultureInfo%2A>, and <xref:System.Reflection.AssemblyName.KeyPair%2A> properties, which together comprise an assembly's full name, or display name. The FullName property is then used to retrieve the display name.  
  
 [!code-cs[AssemblyName_CodeBase#4](~/add/codesnippet/csharp/p-system.reflection.asse_6_1.cs)]
 [!code-cpp[AssemblyName_CodeBase#4](~/add/codesnippet/cpp/p-system.reflection.asse_6_1.cpp)]
 [!code-vb[AssemblyName_CodeBase#4](~/add/codesnippet/visualbasic/p-system.reflection.asse_6_1.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetAssemblyName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The path for the assembly whose <see cref="T:System.Reflection.AssemblyName" /> is to be returned.</param>
        <summary>Gets the <see cref="T:System.Reflection.AssemblyName" /> for a given file.</summary>
        <returns>An object that represents the given assembly file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This will only work if the file contains an assembly manifest. This method causes the file to be opened and closed, but the assembly is not added to this domain.  
  
   
  
## Examples  
 The following example gets the <xref:System.Reflection.AssemblyName> for an assembly on disk. It will not run unless you replace the string "MyAssembly.exe" with the file name of an assembly (including the path, if necessary) on your hard disk. Alternatively, you can compile this example as "MyAssembly.exe".  
  
 [!code-cpp[AssemblyName_GetAssemblyName#1](~/add/codesnippet/cpp/m-system.reflection.asse_18_1.cpp)]
 [!code-cs[AssemblyName_GetAssemblyName#1](~/add/codesnippet/csharp/m-system.reflection.asse_18_1.cs)]
 [!code-vb[AssemblyName_GetAssemblyName#1](~/add/codesnippet/visualbasic/m-system.reflection.asse_18_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> is invalid, such as an assembly with an invalid culture.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> is not found.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have path discovery permission.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different sets of evidence.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to information in the path. Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">The object to be populated with serialization information.</param>
        <param name="context">The destination context of the serialization.</param>
        <summary>Gets serialization information with all the data needed to recreate an instance of this <see langword="AssemblyName" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetPublicKey">
      <MemberSignature Language="C#" Value="public byte[] GetPublicKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetPublicKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetPublicKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the public key of the assembly.</summary>
        <returns>A byte array that contains the public key of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the <xref:System.Reflection.AssemblyName.SetPublicKey%2A> method is used to give the assembly a public key. The GetPublicKey method is then used to retrieve the public key, which is displayed to the console.  
  
 [!code-vb[AssemblyName_KeyPair#2](~/add/codesnippet/visualbasic/m-system.reflection.asse_6_1.vb)]
 [!code-cs[AssemblyName_KeyPair#2](~/add/codesnippet/csharp/m-system.reflection.asse_6_1.cs)]
 [!code-cpp[AssemblyName_KeyPair#2](~/add/codesnippet/cpp/m-system.reflection.asse_6_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">A public key was provided (for example, by using the <see cref="System.Reflection.AssemblyName.SetPublicKey%2A" /> method), but no public key token was provided.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicKeyToken">
      <MemberSignature Language="C#" Value="public byte[] GetPublicKeyToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetPublicKeyToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetPublicKeyToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the public key token, which is the last 8 bytes of the SHA-1 hash of the public key under which the application or assembly is signed.</summary>
        <returns>A byte array that contains the public key token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> method is used to set the assembly's public key token. The GetPublicKeyToken method is then used to retrieve the public key token, which is displayed to the console.  
  
 [!code-vb[AssemblyName_KeyPair#3](~/add/codesnippet/visualbasic/m-system.reflection.asse_21_1.vb)]
 [!code-cs[AssemblyName_KeyPair#3](~/add/codesnippet/csharp/m-system.reflection.asse_21_1.cs)]
 [!code-cpp[AssemblyName_KeyPair#3](~/add/codesnippet/cpp/m-system.reflection.asse_21_1.cpp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Assemblies.AssemblyHashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the hash algorithm used by the assembly manifest.</summary>
        <value>The hash algorithm used by the assembly manifest.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Starting with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the HashAlgorithm property of an <xref:System.Reflection.AssemblyName> object that is returned by the <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=fullName> method is <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=fullName> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=fullName> enumeration. In previous versions of the .NET Framework, the HashAlgorithm property returned <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=fullName> in this situation.  
  
   
  
## Examples  
 The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the HashAlgorithm property is used to set the hash algorithm for the assembly manifest.  
  
 [!code-cs[AssemblyName_CodeBase#3](~/add/codesnippet/csharp/p-system.reflection.asse_11_1.cs)]
 [!code-cpp[AssemblyName_CodeBase#3](~/add/codesnippet/cpp/p-system.reflection.asse_11_1.cpp)]
 [!code-vb[AssemblyName_CodeBase#3](~/add/codesnippet/visualbasic/p-system.reflection.asse_11_1.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPair">
      <MemberSignature Language="C#" Value="public System.Reflection.StrongNameKeyPair KeyPair { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.StrongNameKeyPair KeyPair" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.KeyPair" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.StrongNameKeyPair</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the public and private cryptographic key pair that is used to create a strong name signature for the assembly.</summary>
        <value>The public and private cryptographic key pair to be used to create a strong name for the assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When the runtime loads an assembly, it does not set the KeyPair property. The getter for the property is only useful if the user set the property before using the <xref:System.Reflection.AssemblyName> object to create a dynamic assembly, and subsequently wants to retrieve the key pair.  
  
   
  
## Examples  
 The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the KeyPair property is used to set the assembly's public and private cryptographic keys. .  
  
 [!code-vb[AssemblyName_KeyPair#1](~/add/codesnippet/visualbasic/p-system.reflection.asse_3_1.vb)]
 [!code-cs[AssemblyName_KeyPair#1](~/add/codesnippet/csharp/p-system.reflection.asse_3_1.cs)]
 [!code-cpp[AssemblyName_KeyPair#1](~/add/codesnippet/cpp/p-system.reflection.asse_3_1.cpp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the simple name of the assembly. This is usually, but not necessarily, the file name of the manifest file of the assembly, minus its extension.</summary>
        <value>The simple name of the assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The manifest file is the file that contains the assembly manifest.  
  
 For example, the simple name of a single-file assembly named "MyAssembly.dll" is "MyAssembly".  
  
   
  
## Examples  
 The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the Name property is used to set the simple name of the dynamic assembly.  
  
 [!code-cpp[AssemblyName_Constructor#2](~/add/codesnippet/cpp/p-system.reflection.asse_8_1.cpp)]
 [!code-vb[AssemblyName_Constructor#2](~/add/codesnippet/visualbasic/p-system.reflection.asse_8_1.vb)]
 [!code-cs[AssemblyName_Constructor#2](~/add/codesnippet/csharp/p-system.reflection.asse_8_1.cs)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.OnDeserialization(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">The source of the deserialization event.</param>
        <summary>Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and is called back by the deserialization event when deserialization is complete.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessorArchitecture">
      <MemberSignature Language="C#" Value="public System.Reflection.ProcessorArchitecture ProcessorArchitecture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.ProcessorArchitecture ProcessorArchitecture" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.ProcessorArchitecture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ProcessorArchitecture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that identifies the processor and bits-per-word of the platform targeted by an executable.</summary>
        <value>One of the enumeration values that identifies the processor and bits-per-word of the platform targeted by an executable.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], this property always returns <xref:System.Reflection.ProcessorArchitecture?displayProperty=fullName> for reference assemblies.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceMatchesDefinition">
      <MemberSignature Language="C#" Value="public static bool ReferenceMatchesDefinition (System.Reflection.AssemblyName reference, System.Reflection.AssemblyName definition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceMatchesDefinition(class System.Reflection.AssemblyName reference, class System.Reflection.AssemblyName definition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.ReferenceMatchesDefinition(System.Reflection.AssemblyName,System.Reflection.AssemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reference" Type="System.Reflection.AssemblyName" />
        <Parameter Name="definition" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="reference">The reference assembly name.</param>
        <param name="definition">The assembly name that is compared to the reference assembly.</param>
        <summary>Returns a value indicating whether two assembly names are the same. The comparison is based on the simple assembly names.</summary>
        <returns>
          <see langword="true" /> if the simple assembly names are the same; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The comparison depends only on the simple assembly name. It ignores version, culture, and public key token.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPublicKey">
      <MemberSignature Language="C#" Value="public void SetPublicKey (byte[] publicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPublicKey(unsigned int8[] publicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="publicKey" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="publicKey">A byte array containing the public key of the assembly.</param>
        <summary>Sets the public key identifying the assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You must also use the <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> method to provide a public key token. Otherwise, a <xref:System.Security.SecurityException> is thrown when the <xref:System.Reflection.AssemblyName.GetPublicKey%2A> method is called.  
  
   
  
## Examples  
 The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the SetPublicKey method is used to give the assembly a public key. The <xref:System.Reflection.AssemblyName.GetPublicKey%2A> method is then used to retrieve the public key, which is displayed to the console.  
  
 [!code-cs[AssemblyName_SetPublicKey#1](~/add/codesnippet/csharp/m-system.reflection.asse_19_1.cs)]
 [!code-cpp[AssemblyName_SetPublicKey#1](~/add/codesnippet/cpp/m-system.reflection.asse_19_1.cpp)]
 [!code-vb[AssemblyName_SetPublicKey#1](~/add/codesnippet/visualbasic/m-system.reflection.asse_19_1.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPublicKeyToken">
      <MemberSignature Language="C#" Value="public void SetPublicKeyToken (byte[] publicKeyToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPublicKeyToken(unsigned int8[] publicKeyToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.SetPublicKeyToken(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="publicKeyToken" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="publicKeyToken">A byte array containing the public key token of the assembly.</param>
        <summary>Sets the public key token, which is the last 8 bytes of the SHA-1 hash of the public key under which the application or assembly is signed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When you set the public key by calling the <xref:System.Reflection.AssemblyName.SetPublicKey%2A> method, you must also use the SetPublicKeyToken method to provide a public key token. Otherwise, a <xref:System.Security.SecurityException> is thrown when the <xref:System.Reflection.AssemblyName.GetPublicKey%2A> method is called.  
  
   
  
## Examples  
 The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the SetPublicKeyToken method is used to set the assembly's public key token. The <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method is then used to retrieve the public key token, which is displayed to the console.  
  
 [!code-cs[AssemblyName_SetPublicKey#2](~/add/codesnippet/csharp/m-system.reflection.asse_16_1.cs)]
 [!code-cpp[AssemblyName_SetPublicKey#2](~/add/codesnippet/cpp/m-system.reflection.asse_16_1.cpp)]
 [!code-vb[AssemblyName_SetPublicKey#2](~/add/codesnippet/visualbasic/m-system.reflection.asse_16_1.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="rgszNames">Passed-in array of names to be mapped.</param>
        <param name="cNames">Count of the names to be mapped.</param>
        <param name="lcid">The locale context in which to interpret the names.</param>
        <param name="rgDispId">Caller-allocated array that receives the IDs corresponding to the names.</param>
        <summary>Maps a set of names to a corresponding set of dispatch identifiers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">The type information to return.</param>
        <param name="lcid">The locale identifier for the type information.</param>
        <param name="ppTInfo">Receives a pointer to the requested type information object.</param>
        <summary>Retrieves the type information for an object, which can then be used to get the type information for an interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Points to a location that receives the number of type information interfaces provided by the object.</param>
        <summary>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.Invoke">
      <MemberSignature Language="C#" Value="void _AssemblyName.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifies the member.</param>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="lcid">The locale context in which to interpret arguments.</param>
        <param name="wFlags">Flags describing the context of the call.</param>
        <param name="pDispParams">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</param>
        <param name="pVarResult">Pointer to the location where the result is to be stored.</param>
        <param name="pExcepInfo">Pointer to a structure that contains exception information.</param>
        <param name="puArgErr">The index of the first argument that has an error.</param>
        <summary>Provides access to properties and methods exposed by an object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::Invoke`, see the MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the full name of the assembly, also known as the display name.</summary>
        <returns>The full name of the assembly, or the class name if the full name cannot be determined.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 See the description of <xref:System.Reflection.AssemblyName> for the format of the returned string.  
  
   
  
## Examples  
 The following example gets an <xref:System.Reflection.AssemblyName> object for a hypothetical `MyAssembly.exe` assembly, and then uses the ToString method to retrieve the full assembly name, or display name.  
  
 [!code-cpp[AssemblyName_GetAssemblyName#2](~/add/codesnippet/cpp/m-system.reflection.asse_7_1.cpp)]
 [!code-cs[AssemblyName_GetAssemblyName#2](~/add/codesnippet/csharp/m-system.reflection.asse_7_1.cs)]
 [!code-vb[AssemblyName_GetAssemblyName#2](~/add/codesnippet/visualbasic/m-system.reflection.asse_7_1.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public Version Version { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the major, minor, build, and revision numbers of the assembly.</summary>
        <value>An object that represents the major, minor, build, and revision numbers of the assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 All components of the version must be integers greater than or equal to zero. Metadata restricts the major, minor, build, and revision components for an assembly to a maximum value of <xref:System.UInt16.MaxValue?displayProperty=fullName> - 1. If a component exceeds this value, no error is thrown; however, in a dynamic assembly, that component is zero.  
  
   
  
## Examples  
 This section contains two examples. The first example shows how to retrieve the version of the currently executing assembly. The second example shows how to use the Version property to specify the assembly version when you emit a dynamic assembly.  
  
 **Example 1**  
  
 The following example retrieves and displays the version numbers of the currently executing assembly and the assembly that contains the <xref:System.String> class.  
  
 [!code-cs[AssemblyName.Version#1](~/add/codesnippet/csharp/p-system.reflection.asse_5_1.cs)]
 [!code-cpp[AssemblyName.Version#1](~/add/codesnippet/cpp/p-system.reflection.asse_5_1.cpp)]
 [!code-vb[AssemblyName.Version#1](~/add/codesnippet/visualbasic/p-system.reflection.asse_5_1.vb)]  
  
 **Example 2**  
  
 The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the Version property is used to specify version information for the assembly.  
  
 [!code-cpp[AssemblyName_Constructor#3](~/add/codesnippet/cpp/p-system.reflection.asse_5_2.cpp)]
 [!code-vb[AssemblyName_Constructor#3](~/add/codesnippet/visualbasic/p-system.reflection.asse_5_2.vb)]
 [!code-cs[AssemblyName_Constructor#3](~/add/codesnippet/csharp/p-system.reflection.asse_5_2.cs)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VersionCompatibility">
      <MemberSignature Language="C#" Value="public System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.VersionCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Assemblies.AssemblyVersionCompatibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the information related to the assembly's compatibility with other assemblies.</summary>
        <value>A value that represents information about the assembly's compatibility with other assemblies.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 VersionCompatibility information indicates, for example, that the assembly cannot execute side-by-side with other versions due to conflicts over a device driver.  
  
 Currently, VersionCompatibility always returns <xref:System.Configuration.Assemblies.AssemblyVersionCompatibility?displayProperty=fullName>, and is not used by the loader. This property is reserved for a future feature.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>