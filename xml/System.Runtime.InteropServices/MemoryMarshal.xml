<Type Name="MemoryMarshal" FullName="System.Runtime.InteropServices.MemoryMarshal">
  <TypeSignature Language="C#" Value="public static class MemoryMarshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MemoryMarshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.MemoryMarshal" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryMarshal" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryMarshal abstract sealed" />
  <TypeSignature Language="F#" Value="type MemoryMarshal = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides methods to interoperate with <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />,  <see cref="T:System.Span`1" />, and  <see cref="T:System.ReadOnlySpan`1" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsBytes&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;byte&gt; AsBytes&lt;T&gt; (ReadOnlySpan&lt;T&gt; span) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; AsBytes&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsBytes(Of T As Structure) (span As ReadOnlySpan(Of T)) As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static ReadOnlySpan&lt;System::Byte&gt; AsBytes(ReadOnlySpan&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member AsBytes : ReadOnlySpan&lt;'T (requires 'T : struct)&gt; -&gt; ReadOnlySpan&lt;byte&gt; (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.AsBytes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the read-only span.</typeparam>
        <param name="span">The source slice to convert.</param>
        <summary>Casts a <see cref="T:System.ReadOnlySpan`1" /> of one primitive type, <paramref name="T" />, to a <see langword="ReadOnlySpan&lt;Byte&gt;" />.</summary>
        <returns>A read-only span of type <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`T` cannot contain pointers or references. `T` is checked at runtime in order to preserve type safety.  

      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="T" /> contains references or pointers.</exception>
        <exception cref="T:System.OverflowException">The <see cref="P:System.ReadOnlySpan`1.Length" /> property of the new <see cref="T:System.ReadOnlySpan`1" /> would exceed <see cref="F:System.Int32.MaxValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AsBytes&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;byte&gt; AsBytes&lt;T&gt; (Span&lt;T&gt; span) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;unsigned int8&gt; AsBytes&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Span`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsBytes(Of T As Structure) (span As Span(Of T)) As Span(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static Span&lt;System::Byte&gt; AsBytes(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member AsBytes : Span&lt;'T (requires 'T : struct)&gt; -&gt; Span&lt;byte&gt; (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.AsBytes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the span.</typeparam>
        <param name="span">The source slice to convert.</param>
        <summary>Casts a <see cref="T:System.Span`1" /> of one primitive type, <paramref name="T" />, to a <see langword="Span&lt;Byte&gt;" />.</summary>
        <returns>A span of type <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`T` cannot contain pointers or references. `T` is checked at runtime in order to preserve type safety.  

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="T" /> contains references or pointers.</exception>
        <exception cref="T:System.OverflowException">The <see cref="P:System.Span`1.Length" /> property of the new <see cref="T:System.Span`1" /> would exceed <see cref="F:System.Int32.MaxValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (ReadOnlyMemory&lt;T&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsMemory(Of T) (memory As ReadOnlyMemory(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static Memory&lt;T&gt; AsMemory(ReadOnlyMemory&lt;T&gt; memory);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ReadOnlyMemory&lt;'T&gt; -&gt; Memory&lt;'T&gt;" Usage="System.Runtime.InteropServices.MemoryMarshal.AsMemory memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the read-only memory buffer.</typeparam>
        <param name="memory">The read-only memory buffer.</param>
        <summary>Creates a <see cref="T:System.Memory`1" /> instance from a <see cref="T:System.ReadOnlyMemory`1" />.</summary>
        <returns>A memory block that represetns the same memory as the <see cref="T:System.ReadOnlyMemory`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

This method must be used with extreme caution. <xref:System.ReadOnlyMemory%601> is used to represent immutable data and other memory that is not meant to be written to. <xref:System.Memory%601> instances created by this method should not be written to. The purpose of this method is to allow variables typed as <xref:System.Memory%601> but only used for reading to store a <xref:System.ReadOnlyMemory%601>. 

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;TTo&gt; Cast&lt;TFrom,TTo&gt; (ReadOnlySpan&lt;TFrom&gt; span) where TFrom : struct where TTo : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!TTo&gt; Cast&lt;struct .ctor (class System.ValueType) TFrom, struct .ctor (class System.ValueType) TTo&gt;(valuetype System.ReadOnlySpan`1&lt;!!TFrom&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cast(Of TFrom As Structure, TTo As Structure) (span As ReadOnlySpan(Of TFrom)) As ReadOnlySpan(Of TTo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : value class where TTo : value class static ReadOnlySpan&lt;TTo&gt; Cast(ReadOnlySpan&lt;TFrom&gt; span);" />
      <MemberSignature Language="F#" Value="static member Cast : ReadOnlySpan&lt;'From (requires 'From : struct)&gt; -&gt; ReadOnlySpan&lt;'o (requires 'o : struct)&gt; (requires 'From : struct and 'o : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.Cast span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;TFrom&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFrom">The type of the source span.</typeparam>
        <typeparam name="TTo">The type of the target span.</typeparam>
        <param name="span">The source slice to convert.</param>
        <summary>Casts a read-only span of one primitive type to a read-only span of another primitive type.</summary>
        <returns>The converted read-only span.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Neither `TFrom` nor `TTo` can contain pointers or references. `TFrom` and `TTo` are checked at runtime in order to preserve type safety.  

This method is supported only on platforms that support misaligned memory access or when the memory block is aligned by other means.

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TFrom" /> or <paramref name="TTo" /> contains references or pointers.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;TTo&gt; Cast&lt;TFrom,TTo&gt; (Span&lt;TFrom&gt; span) where TFrom : struct where TTo : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!TTo&gt; Cast&lt;struct .ctor (class System.ValueType) TFrom, struct .ctor (class System.ValueType) TTo&gt;(valuetype System.Span`1&lt;!!TFrom&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cast(Of TFrom As Structure, TTo As Structure) (span As Span(Of TFrom)) As Span(Of TTo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : value class where TTo : value class static Span&lt;TTo&gt; Cast(Span&lt;TFrom&gt; span);" />
      <MemberSignature Language="F#" Value="static member Cast : Span&lt;'From (requires 'From : struct)&gt; -&gt; Span&lt;'o (requires 'o : struct)&gt; (requires 'From : struct and 'o : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.Cast span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;TFrom&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFrom">The type of the source span.</typeparam>
        <typeparam name="TTo">The type of the target span.</typeparam>
        <param name="span">The source slice to convert.</param>
        <summary>Casts a span of one primitive type to a span of another primitive type.</summary>
        <returns>The converted span.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Neither `TFrom` nor `TTo` can contain pointers or references. `TFrom` and `TTo` are checked at runtime in order to preserve type safety.  

The cast occurs in an unchecked context. If the range of `TTo` is less than the range of `TFrom`, data loss can occur. For example, if `TFrom` is <xref:System.Int64>, one of the `ReadOnlySpan<Int32>` values is 0x100001111110F0F, and `TTo` is <xref:System.Int32>, the resulting value is 11110F0F.

This method is supported only on platforms that support misaligned memory access or when the memory block is aligned by other means.

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TFrom" /> or <paramref name="TTo" /> contains references or pointers.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromPinnedArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; CreateFromPinnedArray&lt;T&gt; (T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; CreateFromPinnedArray&lt;T&gt;(!!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromPinnedArray(Of T) (array As T(), start As Integer, length As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static Memory&lt;T&gt; CreateFromPinnedArray(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="static member CreateFromPinnedArray : 'T[] * int * int -&gt; Memory&lt;'T&gt;" Usage="System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray (array, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the array.</typeparam>
        <param name="array">The pre-pinned source array.</param>
        <param name="start">The index of <paramref name="array" /> at which to begin the memory block.</param>
        <param name="length">The number of items to include in the memory block.</param>
        <summary>Creates a new memory buffer over the portion of the pre-pinned target array beginning at the <paramref name="start" /> index and consisting of <paramref name="length" /> items.</summary>
        <returns>A block of memory over the specified elements of <paramref name="array" />. If <paramref name="array" /> is <see langword="null" />, or if <paramref name="start" /> and <paramref name="length" /> are 0, the method returns a <see cref="T:System.Memory`1" /> instance of <see cref="System.Memory`1.Length" /> zero. </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

The array must already be pinned before this method is called, and that array must not be unpinned while the <xref:System.Memory%601> buffer that it returns is still in use. Calling this method on an unpinned array could result in memory corruption.

       ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="array" /> is covariant, and the type of <paramref name="array" /> is not exactly <paramref name="T[]" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="start" /> or the end index is not in the range of 0 to <see cref="P:System.Array.Length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReadOnlySpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; CreateReadOnlySpan&lt;T&gt; (ref T reference, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; CreateReadOnlySpan&lt;T&gt;(!!T&amp; reference, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateReadOnlySpan(Of T) (ByRef reference As T, length As Integer) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static ReadOnlySpan&lt;T&gt; CreateReadOnlySpan(T % reference, int length);" />
      <MemberSignature Language="F#" Value="static member CreateReadOnlySpan :  * int -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan (reference, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reference" Type="T" RefType="ref" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the data items.</typeparam>
        <param name="reference">A reference to data.</param>
        <param name="length">The number of <paramref name="T" /> elements that <paramref name="reference" /> contains.</param>
        <summary>Creates a new read-only span over a portion of a regular managed object.</summary>
        <returns>A read-only span.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

This method can be useful if part of a managed object represents a fixed array. 

> [!WARNING]
> This method should be used with caution. It is dangerous because the `length` argument is not checked. In addition, the lifetime of the returned span is not validated for safety by span-aware languages.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; CreateSpan&lt;T&gt; (ref T reference, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; CreateSpan&lt;T&gt;(!!T&amp; reference, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSpan(Of T) (ByRef reference As T, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static Span&lt;T&gt; CreateSpan(T % reference, int length);" />
      <MemberSignature Language="F#" Value="static member CreateSpan :  * int -&gt; Span&lt;'T&gt;" Usage="System.Runtime.InteropServices.MemoryMarshal.CreateSpan (reference, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reference" Type="T" RefType="ref" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the data items.</typeparam>
        <param name="reference">A reference to data.</param>
        <param name="length">The number of <paramref name="T" /> elements that <paramref name="reference" /> contains.</param>
        <summary>Creates a new span over a portion of a regular managed object.</summary>
        <returns>A span.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

This method can be useful if part of a managed object represents a fixed array. 

> [!WARNING]
> This method should be used with caution. It is dangerous because the `length` argument is not checked. In addition, the lifetime of the returned span is not validated for safety by span-aware languages.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReference&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetReference&lt;T&gt; (ReadOnlySpan&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetReference&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReference(Of T) (span As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % GetReference(ReadOnlySpan&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member GetReference : ReadOnlySpan&lt;'T&gt; -&gt; " Usage="System.Runtime.InteropServices.MemoryMarshal.GetReference span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the span.</typeparam>
        <param name="span">The read-only span from which the reference is retrieved.</param>
        <summary>Returns a reference to the element of the read-only span at index 0.</summary>
        <returns>A reference to the element at index 0. </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

If the read-only span is empty, this method returns a reference to the location where the element at index 0 would have been stored. Such a reference may or may not be `null`. The returned reference can be used for pinning, but it must never be dereferenced.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReference&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetReference&lt;T&gt; (Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetReference&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReference(Of T) (span As Span(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % GetReference(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member GetReference : Span&lt;'T&gt; -&gt; " Usage="System.Runtime.InteropServices.MemoryMarshal.GetReference span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the span.</typeparam>
        <param name="span">The span from which the reference is retrieved.</param>
        <summary>Returns a reference to the element of the span at index 0.</summary>
        <returns>A reference to the element at index 0. </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

If the span is empty, this method returns a reference to the location where the element at index 0 would have been stored. Such a reference may or may not be `null`. The returned reference can be used for pinning, but it must never be dereferenced.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Read&lt;T&gt; (ReadOnlySpan&lt;byte&gt; source) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Read&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read(Of T As Structure) (source As ReadOnlySpan(Of Byte)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static T Read(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member Read : ReadOnlySpan&lt;byte&gt; -&gt; 'T (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.Read source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the item to retrieve from the read-only span.</typeparam>
        <param name="source">A read-only span.</param>
        <summary>Reads a structure of type <param name="T" /> out of a read-only span of bytes.</summary>
        <returns>The structure retrieved from the read-only span.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`T` cannot contain pointers or references. `It is checked at runtime in order to preserve type safety.  

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="T" /> contains references or pointers.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="source" /> is smaller than <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToEnumerable&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; ToEnumerable&lt;T&gt; (ReadOnlyMemory&lt;T&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; ToEnumerable&lt;T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToEnumerable(Of T) (memory As ReadOnlyMemory(Of T)) As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::Generic::IEnumerable&lt;T&gt; ^ ToEnumerable(ReadOnlyMemory&lt;T&gt; memory);" />
      <MemberSignature Language="F#" Value="static member ToEnumerable : ReadOnlyMemory&lt;'T&gt; -&gt; seq&lt;'T&gt;" Usage="System.Runtime.InteropServices.MemoryMarshal.ToEnumerable memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the items in the read-only memory buffer.</typeparam>
        <param name="memory">A read-only memory buffer.</param>
        <summary>Creates an <see cref="T:System.Collections.Generic.IEnumerable`1" /> view of the given read-only memory buffer.</summary>
        <returns>An enumerable view of <paramref name="memory" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

This method allows a read-only memory buffer to be used in existing APIs that require a parameter of type <xref:System.Collections.Generic.IEnumerable%601>. 

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetArray&lt;T&gt; (ReadOnlyMemory&lt;T&gt; memory, out ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetArray&lt;T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, [out] valuetype System.ArraySegment`1&lt;!!T&gt;&amp; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetArray(Of T) (memory As ReadOnlyMemory(Of T), ByRef segment As ArraySegment(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryGetArray(ReadOnlyMemory&lt;T&gt; memory, [Runtime::InteropServices::Out] ArraySegment&lt;T&gt; % segment);" />
      <MemberSignature Language="F#" Value="static member TryGetArray : ReadOnlyMemory&lt;'T&gt; *  -&gt; bool" Usage="System.Runtime.InteropServices.MemoryMarshal.TryGetArray (memory, segment)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" />
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the read-only memory buffer.</typeparam>
        <param name="memory">A read-only memory buffer.</param>
        <param name="segment">When this method returns, contains the array segment retrieved from the underlying read-only memory buffer. If the method fails, the method returns a default array segment. </param>
        <summary>Tries to get an array segment from the underlying memory buffer. The return value indicates the success of the operation. </summary>
        <returns>
          <see langword="true" /> if the method call succeeds; <see langword="false" /> otherwise.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMemoryManager&lt;T,TManager&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetMemoryManager&lt;T,TManager&gt; (ReadOnlyMemory&lt;T&gt; memory, out TManager manager) where TManager : System.Buffers.MemoryManager&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetMemoryManager&lt;T, (class System.Buffers.MemoryManager`1&lt;!!T&gt;) TManager&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, [out] !!TManager&amp; manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetMemoryManager(Of T, TManager) (memory As ReadOnlyMemory(Of T), ByRef manager As TManager) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TManager&gt;&#xA; where TManager : System::Buffers::MemoryManager&lt;T&gt; static bool TryGetMemoryManager(ReadOnlyMemory&lt;T&gt; memory, [Runtime::InteropServices::Out] TManager % manager);" />
      <MemberSignature Language="F#" Value="static member TryGetMemoryManager : ReadOnlyMemory&lt;'T&gt; *  -&gt; bool (requires 'Manager :&gt; System.Buffers.MemoryManager&lt;'T&gt;)" Usage="System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager (memory, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TManager">
          <Constraints>
            <BaseTypeName>System.Buffers.MemoryManager&lt;T&gt;</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" />
        <Parameter Name="manager" Type="TManager" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the items in the read-only memory buffer.</typeparam>
        <typeparam name="TManager">The type of the <see cref="T:System.Buffers.MemoryManager`1" /> to retrieve.</typeparam>
        <param name="memory">The read-only memory buffer for which to get the memory manager.</param>
        <param name="manager">When the method returns, the manager of <paramref name="memory" />. </param>
        <summary>Tries to retrieve a <see cref="T:System.Buffers.MemoryManager`1" /> from the underlying read-only memory buffer.</summary>
        <returns>
          <see langword="true" /> if the method retrieved the memory manager; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMemoryManager&lt;T,TManager&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetMemoryManager&lt;T,TManager&gt; (ReadOnlyMemory&lt;T&gt; memory, out TManager manager, out int start, out int length) where TManager : System.Buffers.MemoryManager&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetMemoryManager&lt;T, (class System.Buffers.MemoryManager`1&lt;!!T&gt;) TManager&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, [out] !!TManager&amp; manager, [out] int32&amp; start, [out] int32&amp; length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetMemoryManager(Of T, TManager) (memory As ReadOnlyMemory(Of T), ByRef manager As TManager, ByRef start As Integer, ByRef length As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TManager&gt;&#xA; where TManager : System::Buffers::MemoryManager&lt;T&gt; static bool TryGetMemoryManager(ReadOnlyMemory&lt;T&gt; memory, [Runtime::InteropServices::Out] TManager % manager, [Runtime::InteropServices::Out] int % start, [Runtime::InteropServices::Out] int % length);" />
      <MemberSignature Language="F#" Value="static member TryGetMemoryManager : ReadOnlyMemory&lt;'T&gt; *  *  *  -&gt; bool (requires 'Manager :&gt; System.Buffers.MemoryManager&lt;'T&gt;)" Usage="System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager (memory, manager, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TManager">
          <Constraints>
            <BaseTypeName>System.Buffers.MemoryManager&lt;T&gt;</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" />
        <Parameter Name="manager" Type="TManager" RefType="out" />
        <Parameter Name="start" Type="System.Int32" RefType="out" />
        <Parameter Name="length" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the items in the read-only memory buffer.</typeparam>
        <typeparam name="TManager">The type of the <see cref="T:System.Buffers.MemoryManager`1" /> to retrieve.</typeparam>
        <param name="memory">The read-only memory buffer for which to get the memory manager.</param>
        <param name="manager">When the method returns, the manager of <paramref name="memory" />. </param>
        <param name="start">When the method returns, the offset from the start of the <paramref name="manager" /> that the <paramref name="memory" /> represents.</param>
        <param name="length">When the method returns, the length of the <paramref name="manager" /> that the <paramref name="memory" /> represents.</param>
        <summary>Tries to retrieve a <see cref="T:System.Buffers.MemoryManager`1" />, start index, and length from the underlying read-only memory buffer.</summary>
        <returns>
          <see langword="true" /> if the method succeeded; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetString">
      <MemberSignature Language="C#" Value="public static bool TryGetString (ReadOnlyMemory&lt;char&gt; memory, out string text, out int start, out int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetString(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory, [out] string&amp; text, [out] int32&amp; start, [out] int32&amp; length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetString (memory As ReadOnlyMemory(Of Char), ByRef text As String, ByRef start As Integer, ByRef length As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetString(ReadOnlyMemory&lt;char&gt; memory, [Runtime::InteropServices::Out] System::String ^ % text, [Runtime::InteropServices::Out] int % start, [Runtime::InteropServices::Out] int % length);" />
      <MemberSignature Language="F#" Value="static member TryGetString : ReadOnlyMemory&lt;char&gt; *  *  *  -&gt; bool" Usage="System.Runtime.InteropServices.MemoryMarshal.TryGetString (memory, text, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" />
        <Parameter Name="text" Type="System.String" RefType="out" />
        <Parameter Name="start" Type="System.Int32" RefType="out" />
        <Parameter Name="length" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="memory">Read-only memory containing a block of characters.</param>
        <param name="text">When the method returns, the string contained in the memory buffer.</param>
        <param name="start">The starting location in <paramref name="text" />.</param>
        <param name="length">The number of characters in <paramref name="text" />.</param>
        <summary>Tries to get the underlying string from a <see langword="System.ReadOnlyMemory&lt;Char&gt;" />.</summary>
        <returns>
          <see langword="true" /> if the method successfully retrieves the underlying string; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryRead&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryRead&lt;T&gt; (ReadOnlySpan&lt;byte&gt; source, out T value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryRead&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryRead(Of T As Structure) (source As ReadOnlySpan(Of Byte), ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool TryRead(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member TryRead : ReadOnlySpan&lt;byte&gt; *  -&gt; bool (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.TryRead (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the structure to retrieve.</typeparam>
        <param name="source">A read-only span of bytes. </param>
        <param name="value">When the method returns, an instance of <paramref name="T" />.</param>
        <summary>Tries to read a structure of type <paramref name="T" /> from a read-only span of bytes.</summary>
        <returns>
          <see langword="true" /> if the method succeeds in retrieving an instance of the structure; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`T` cannot contain pointers or references. `It is checked at runtime in order to preserve type safety.  

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="T" /> contains references or pointers.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryWrite&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryWrite&lt;T&gt; (Span&lt;byte&gt; destination, ref T value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWrite&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Span`1&lt;unsigned int8&gt; destination, !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWrite(Of T As Structure) (destination As Span(Of Byte), ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool TryWrite(Span&lt;System::Byte&gt; destination, T % value);" />
      <MemberSignature Language="F#" Value="static member TryWrite : Span&lt;byte&gt; *  -&gt; bool (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.TryWrite (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the structure.</typeparam>
        <param name="destination">The span of bytes to contain the structure.</param>
        <param name="value">The structure to be written to the span.</param>
        <summary>Tries to writes a structure of type <paramref name="T" /> into a span of bytes.</summary>
        <returns>
          <see langword="true" /> if the write operation succeeded; otherwise, <see langword="false" />. The method returns <see langword="false" /> if the span is too small to contain <paramref name="T" />. </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`T` cannot contain pointers or references. `It is checked at runtime in order to preserve type safety.  

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TFrom" /> or <paramref name="TTo" /> contains references or pointers.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Write&lt;T&gt; (Span&lt;byte&gt; destination, ref T value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Span`1&lt;unsigned int8&gt; destination, !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write(Of T As Structure) (destination As Span(Of Byte), ByRef value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static void Write(Span&lt;System::Byte&gt; destination, T % value);" />
      <MemberSignature Language="F#" Value="static member Write : Span&lt;byte&gt; *  -&gt; unit (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.Write (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the structure.</typeparam>
        <param name="destination">The span of bytes to contain the structure.</param>
        <param name="value">The structure to be written to the span.</param>
        <summary>Writes a structure of type <paramref name="T" /> into a span of bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`T` cannot contain pointers or references. `It is checked at runtime in order to preserve type safety.  

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="T" /> contains references or pointers.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="destination" /> is too small to contain <paramref name="value" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>