<Type Name="IMessageFilterTable&lt;TFilterData&gt;" FullName="System.ServiceModel.Dispatcher.IMessageFilterTable&lt;TFilterData&gt;">
  <TypeSignature Language="C#" Value="public interface IMessageFilterTable&lt;TFilterData&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;, System.Collections.Generic.IDictionary&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IMessageFilterTable`1&lt;TFilterData&gt; implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Dispatcher.IMessageFilterTable`1" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TFilterData" />
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TFilterData">The type of data associated with each filter in the table.</typeparam>
    <summary>An <see langword="interface" /> that defines the contract that a filter table must implement to inspect messages with query criteria derived from one or more filters.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The filter table is a core component of the filter engine. The primary use of the filter engine in [!INCLUDE[indigo1](~/includes/indigo1-md.md)] is to match application logic to messages by finding all the filters that match a message.  
  
 A filter table allows multiple filters to be matched against a single message more efficiently than they can be matched separately. A filter table associates filter data with filters. The table is a collection of key-value pairs, where the key is the <xref:System.ServiceModel.Dispatcher.MessageFilter>, and the value is the associated filter data. Filter data can be any data of the type specified in the generic parameter and can be used to specify what actions to take if a message is matched by a filter in the table.  
  
 Filter table entries can be accessed using the <xref:System.Collections.Generic.IDictionary%602> functionality that <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601> inherits.  
  
 Note that a filter instance can only be added to a given <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601> once. To add multiple instances of this filter to the same filter table, use a filter constructor to create additional instances.  
  
 A filter matches a message when the message satisfies the query criteria of the filter. There are four overloaded matching methods. The data returned is either the filter data or the <xref:System.ServiceModel.Dispatcher.MessageFilter> objects themselves. This data is returned whether multiple matches are allowed or only a single match. The following table shows this information for each overload.  
  
|Method Name|Matches|Data Returned|  
|-----------------|-------------|-------------------|  
|<xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValue%2A>|Single|`FilterData`|  
|<xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A>|Single|<xref:System.ServiceModel.Dispatcher.MessageFilter>|  
|<xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A>|Multiple|`FilterData`|  
|<xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilters%2A>|Multiple|<xref:System.ServiceModel.Dispatcher.MessageFilter> objects|  
  
 Each method contains two overloads. The difference between the two overloads is that one takes a <xref:System.ServiceModel.Channels.Message> parameter and is not permitted to examine the contents of the body; the other takes a <xref:System.ServiceModel.Channels.MessageBuffer> parameter and can examine any part of the message. If you call a method with the message parameter, and the filter table contains a filter that examines the content of the message body, an exception is thrown. If you are unsure about the filters in a table, call the overload that takes a message buffer.  
  
 Message headers are automatically buffered and can be inspected by a filter without being consumed. But if the body is to be inspected by a filter, then the entire message must be buffered because an unbuffered message body is consumed by a query and its contents destroyed.  
  
 The following classes implement <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601>:  
  
-   <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601>  
  
-   <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601>  
  
 ]]></format>
    </remarks>
    <threadsafe>Filter tables are thread-safe with respect to matching operations, but are not thread-safe with respect to modification. Threads that access a filter table should be synchronized by the <see cref="T:System.Threading.ReaderWriterLock" /> or similar locking semantic. This lock allows multiple reads of a filter table (for example, a match operation) to run simultaneously, but in order to write to a filter table (for example, adding a filter), a thread must wait for an exclusive lock.  
  
 All compilation is done when filters are added to the table. If you create a filter table in advance, and never edit it, locking is not necessary during a match.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetMatchingFilter">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a filter from the table whose query criteria are satisfied by a specified message or buffered message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method when a single filter is expected to match the message and the matching filter is required.  
  
 Use <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> if the body content does not require examination. Use <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> if the contents of the message body may require examination.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If more than one filter matches the message, a <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> must be thrown.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.Message message, out System.ServiceModel.Dispatcher.MessageFilter result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.Message message, class System.ServiceModel.Dispatcher.MessageFilter result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.Message,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="message">The <see cref="T:System.ServiceModel.Channels.Message" /> to test.</param>
        <param name="result">To be added.</param>
        <summary>Returns a value that indicates whether the match criterion of exactly one filter in the table is satisfied by the specified message, and returns that filter in an <see langword="out" /> parameter.</summary>
        <returns>
          <see langword="true" /> if the match criterion of at least one filter in the table is satisfied by <paramref name="message" />; <see langword="false" /> if no filter is satisfied.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method when a single filter is expected to match the message and the matching filter is required.  
  
 If the body of the message must be inspected by a filter in the filter table, use the <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> version of the method.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If more than one filter matches the message, a <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> must be thrown.  
  
 This version takes a <see cref="T:System.ServiceModel.Channels.Message" /> and must throw an <see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" /> if it tries to examine the message body.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.MessageBuffer buffer, out System.ServiceModel.Dispatcher.MessageFilter result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.MessageBuffer buffer, class System.ServiceModel.Dispatcher.MessageFilter result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.MessageBuffer,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="result">To be added.</param>
        <summary>Returns a value that indicates whether the match criterion of exactly one filter in the table is satisfied by the specified message or buffered message, and returns that filter in an <see langword="out" /> parameter.</summary>
        <returns>
          <see langword="true" /> if the match criterion of at least one filter in the table is satisfied by <paramref name="messageBuffer" />; <see langword="false" /> if no filter is satisfied.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method when a single filter is expected to match the buffered message, the matching filter must be returned, and the body of the message may have to be inspected.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingFilters">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds the filters whose query criteria are satisfied by a specified message or buffered message to a collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use one of these methods when more than one filter is expected to match the message and the matching filters are required. Note that the collection that contains the filters is not cleared before the results are added. This allows you to accumulate all matches across multiple filter tables into a single collection.  
  
 If the body of the message must be inspected by a filter in the filter table, buffer the message and pass it to the <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilters%2A> method. Otherwise, use <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 The matching <xref:System.ServiceModel.Dispatcher.MessageFilter> objects are stored in the `results` parameter. The filter data can then be recovered from the filter table using these filters as keys with the methods provided by <xref:System.Collections.Generic.IDictionary%602>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.Message message, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.Message message, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="message">The <see cref="T:System.ServiceModel.Channels.Message" /> to test.</param>
        <param name="results">Reference parameter that stores the <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> objects that match in <see cref="T:System.Collections.Generic.ICollection`1" />&lt;Filter&gt;.</param>
        <summary>Returns a value that indicates whether the match criterion of a filter in the table is satisfied by the specified message, and adds the matching filters to a collection.</summary>
        <returns>
          <see langword="true" /> if the match criterion of at least one filter in the table is satisfied by <paramref name="message" />; <see langword="false" /> if no filter is satisfied.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method when more than one filter is expected to match the message, the matching filters are required, and the body of the message does not have to be inspected.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>This version takes a <see cref="T:System.ServiceModel.Channels.Message" /> and must throw an <see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" /> if it tries to examine the message body.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.MessageBuffer buffer, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.MessageBuffer buffer, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="results">Reference parameter that stores the <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> objects that match in <see cref="T:System.Collections.Generic.ICollection`1" />&lt;Filter&gt;.</param>
        <summary>Returns a value that indicates whether the match criterion of a filter in the table is satisfied by the specified buffered message, and adds the matching filters to a collection.</summary>
        <returns>
          <see langword="true" /> if the match criterion of at least one filter in the table is satisfied by <paramref name="messageBuffer" />; <see langword="false" /> if no filter is satisfied.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method when more than one filter is expected to match the buffered message, the matching filter is required, and the body of the message may have to be inspected.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingValue">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a value that indicates whether the match criterion of a filter in the table is satisfied by the specified message or buffered message, and returns the filter data for the filter that matched.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use one of these methods when, at most, one filter is expected to match the message and only the filter data from the matching filter must be recovered. These methods return a boolean that indicates whether a matching filter was found and set the `data` reference parameter to the matching filter data.  
  
 Use <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> if the body of the message is not inspected by any of the filters in the filter table.  
  
 If the body of the message may be inspected by a filter in the filter table, buffer the message and pass it to the <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> version of the method.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If more than one filter matches the message, a <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> must be thrown.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.Message message, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.Message message, !TFilterData data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.Message,`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="value" Type="TFilterData&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="message">The <see cref="T:System.ServiceModel.Channels.Message" /> to test.</param>
        <param name="data">To be added.</param>
        <summary>Returns a value that indicates whether the match criterion of exactly one filter in the table is satisfied by the specified message, and adds the matching filter data to a collection.</summary>
        <returns>
          <see langword="true" /> if the match criterion of exactly one filter in the table is satisfied by the message; <see langword="false" /> if no filter is satisfied.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method when a single filter is expected to match the message and only the filter data from the matching filter must be recovered.  
  
 This method expects at most a single matching filter. If more than one filter matches, a <xref:System.ServiceModel.Dispatcher.MultipleFilterMatchesException> must be thrown.  
  
 If the body of the message must be inspected by a filter in the filter table, buffer the message using <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%2A> and pass it to the <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValue%2A> version of the method.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If more than one filter matches the message, a <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> must be thrown.  
  
 This overload takes a <see cref="T:System.ServiceModel.Channels.Message" /> and must throw an <see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" /> if it tries to examine the message body.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.MessageBuffer buffer, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.MessageBuffer buffer, !TFilterData data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.MessageBuffer,`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="value" Type="TFilterData&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="data">To be added.</param>
        <summary>Returns a value that indicates whether the match criterion of exactly one filter in the table is satisfied by the specified buffered message, and adds the matching filter data to a collection.</summary>
        <returns>
          <see langword="true" /> if the match criterion of exactly one filter in the table is satisfied by the message; <see langword="false" /> if no filter is satisfied.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method when a single filter is expected to match the buffered message, only the filter data from the matching filter must be recovered, and the body of the message may have to be inspected.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>If more than one filter matches the message, a <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> must be thrown.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingValues">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds the filter data of the filters that match the specified message or buffered message to a collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method when more than one filter is expected to match and only the matching filter data is required. These methods return a boolean that indicates whether matching filters were found and put any matching filter data into a collection.  
  
 Note that the collection that contains the filter data is not cleared before the results are added. This allows you to accumulate all matches across multiple filter tables into a single collection.  
  
 Use <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A> if the contents of the message body do not require examination. Use <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A> if the contents of the message body requires examination.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.Message message, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.Message message, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="message">The <see cref="T:System.ServiceModel.Channels.Message" /> to test.</param>
        <param name="results">Reference parameter that stores the filter data of the matching filters in a generic collection.</param>
        <summary>Returns a value that indicates whether the match criterion of at least one filter in the table is satisfied by the specified message, and adds the <paramref name="FilterData" /> of the matching filters to a collection.</summary>
        <returns>
          <see langword="true" /> if the match criterion of at least one filter in the table is satisfied by <paramref name="message" />; <see langword="false" /> if no filter is satisfied.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method when one or more filters are expected to match the message, only the filter data is required, and the contents of the body of the message are not to be inspected.  
  
 The filter data of the matching <xref:System.ServiceModel.Dispatcher.MessageFilter> objects is stored in the `results` parameter.  
  
 If the body of the message is inspected by a filter in the filter table, buffer the message and pass it to the <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A> version of the method.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.MessageBuffer buffer, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.MessageBuffer buffer, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="results">Reference parameter that stores the filter data of the matching filters in a generic <see cref="T:System.Collections.Generic.ICollection`1" />&lt;<c>FilterData</c>&gt;.</param>
        <summary>Returns a value that indicates whether the match criterion of at least one filter in the table is satisfied by the specified buffered message, and adds the <paramref name="FilterData" /> of the matching filters to a collection.</summary>
        <returns>
          <see langword="true" /> if the match criterion of at least one filter in the table is satisfied by <paramref name="messageBuffer" />; <see langword="false" /> if no filter is satisfied.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method when one or more filters are expected to match the buffered message, only the filter data is required, and the body of the message may require inspection.  
  
 The filter data of the matching <xref:System.ServiceModel.Dispatcher.MessageFilter> objects is stored in the `results` parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
