<Type Name="MultiBinding" FullName="System.Windows.Data.MultiBinding">
  <TypeSignature Language="C#" Value="public class MultiBinding : System.Windows.Data.BindingBase, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MultiBinding extends System.Windows.Data.BindingBase implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.MultiBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class MultiBinding&#xA;Inherits BindingBase&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class MultiBinding : System::Windows::Data::BindingBase, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type MultiBinding = class&#xA;    inherit BindingBase&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Data.BindingBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Bindings")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Describes a collection of <see cref="T:System.Windows.Data.Binding" /> objects attached to a single binding target property.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You can specify multiple bindings in a <xref:System.Windows.Data.MultiBinding> object. When you use the <xref:System.Windows.Data.MultiBinding> object with a converter, it produces a final value for the binding target based on the values of those bindings. For example, color might be computed from red, blue, and green values, which can be values from the same or different binding source objects. When a value moves from the target to the sources, the target property value is translated to a set of values that are fed back into the bindings.  
  
 The values of the <xref:System.Windows.Data.MultiBinding.Mode%2A> and <xref:System.Windows.Data.MultiBinding.UpdateSourceTrigger%2A> properties determine the functionality of the <xref:System.Windows.Data.MultiBinding> and are used as the default values for all the bindings in the collection unless an individual binding overrides these properties. For example, if the <xref:System.Windows.Data.MultiBinding.Mode%2A> property on the <xref:System.Windows.Data.MultiBinding> object is set to <xref:System.Windows.Data.BindingMode.TwoWay>, then all the bindings in the collection are considered <xref:System.Windows.Data.BindingMode.TwoWay> unless you set a different <xref:System.Windows.Data.MultiBinding.Mode%2A> value on one of the bindings explicitly. For more information, see the <xref:System.Windows.Data.Binding.Mode%2A?displayProperty=nameWithType> and <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A?displayProperty=nameWithType> properties.  
  
 <xref:System.Windows.Data.MultiBinding> currently supports only objects of type <xref:System.Windows.Data.Binding> and not <xref:System.Windows.Data.MultiBinding> or <xref:System.Windows.Data.PriorityBinding>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Data.IMultiValueConverter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MultiBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.MultiBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MultiBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Data.MultiBinding" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Bindings">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingBase&gt; Bindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Data.BindingBase&gt; Bindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.Bindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Bindings As Collection(Of BindingBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Data::BindingBase ^&gt; ^ Bindings { System::Collections::ObjectModel::Collection&lt;System::Windows::Data::BindingBase ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Bindings : System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingBase&gt;" Usage="System.Windows.Data.MultiBinding.Bindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingBase&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of <see cref="T:System.Windows.Data.Binding" /> objects within this <see cref="T:System.Windows.Data.MultiBinding" /> instance.</summary>
        <value>A collection of <see cref="T:System.Windows.Data.Binding" /> objects. <see cref="T:System.Windows.Data.MultiBinding" /> currently supports only objects of type <see cref="T:System.Windows.Data.Binding" /> and not <see cref="T:System.Windows.Data.MultiBinding" /> or <see cref="T:System.Windows.Data.PriorityBinding" />. Adding a <see cref="T:System.Windows.Data.Binding" /> child to a <see cref="T:System.Windows.Data.MultiBinding" /> object implicitly adds the child to the <see cref="T:System.Windows.Data.BindingBase" /> collection for the <see cref="T:System.Windows.Data.MultiBinding" /> object.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  This property can be set in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] only by using the syntax that is shown, or by accessing the collection object and using its various methods, such as `Add`. The property used to access the collection object is read-only, whereas the collection itself is read/write.  
  
<a name="xamlPropertyElementUsage_Bindings"></a>   
## XAML Property Element Usage  
  
```  
<object>  
  oneOrMoreBindings  
</object>  
  
```  
  
<a name="xamlValues_Bindings"></a>   
## XAML Values  
 *oneOrMoreBindings*  
 One or more <xref:System.Windows.Data.Binding> objects.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Converter">
      <MemberSignature Language="C#" Value="public System.Windows.Data.IMultiValueConverter Converter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.IMultiValueConverter Converter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.Converter" />
      <MemberSignature Language="VB.NET" Value="Public Property Converter As IMultiValueConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::IMultiValueConverter ^ Converter { System::Windows::Data::IMultiValueConverter ^ get(); void set(System::Windows::Data::IMultiValueConverter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Converter : System.Windows.Data.IMultiValueConverter with get, set" Usage="System.Windows.Data.MultiBinding.Converter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.IMultiValueConverter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the converter to use to convert the source values to or from the target value.</summary>
        <value>A value of type <see cref="T:System.Windows.Data.IMultiValueConverter" /> that indicates the converter to use. The default value is <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Individual bindings in the collection can have their own value <xref:System.Windows.Data.Binding.Converter%2A>. For more information, see <xref:System.Windows.Data.IValueConverter>.  
  
<a name="xamlAttributeUsage_Converter"></a>   
## XAML Attribute Usage  
  
```  
<object Converter="myConverter"/>  
```  
  
<a name="xamlValues_Converter"></a>   
## XAML Values  
 *myConverter*  
 A resource reference to a class that implements the <xref:System.Windows.Data.IMultiValueConverter> interface, which includes implementations of the <xref:System.Windows.Data.IMultiValueConverter.Convert%2A> and <xref:System.Windows.Data.IMultiValueConverter.ConvertBack%2A> methods. To refer to a value converter, use the [Markup Extensions and WPF XAML](~/docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConverterCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo ConverterCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo ConverterCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.ConverterCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property ConverterCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ ConverterCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConverterCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Data.MultiBinding.ConverterCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.CultureInfoIetfLanguageTagConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Globalization.CultureInfo" /> object that applies to any converter assigned to bindings wrapped by the <see cref="T:System.Windows.Data.MultiBinding" /> or on the <see cref="T:System.Windows.Data.MultiBinding" /> itself.</summary>
        <value>A valid <see cref="T:System.Globalization.CultureInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_ConverterCulture"></a>   
## XAML Attribute Usage  
  
```  
<object ConverterCulture="ietfLanguageTag"/>  
```  
  
<a name="xamlValues_ConverterCulture"></a>   
## XAML Values  
 *ietfLanguageTag*  
 A string used to set the <xref:System.Globalization.CultureInfo>. This string is used to internally call. <xref:System.Globalization.CultureInfo.GetCultureInfoByIetfLanguageTag%2A>. For details on the string format, see <xref:System.Globalization.CultureInfo.GetCultureInfoByIetfLanguageTag%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConverterParameter">
      <MemberSignature Language="C#" Value="public object ConverterParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ConverterParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.ConverterParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property ConverterParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ConverterParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConverterParameter : obj with get, set" Usage="System.Windows.Data.MultiBinding.ConverterParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an optional parameter to pass to a converter as additional information.</summary>
        <value>A parameter to pass to a converter. The default value is <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlPropertyElementUsage_ConverterParameter"></a>   
## XAML Property Element Usage  
  
```  
<object>  
  <object.ConverterParameter>  
    converterParameter  
  </object.ConverterParameter>  
</object>  
```  
  
<a name="xamlAttributeUsage_ConverterParameter"></a>   
## XAML Attribute Usage  
  
```  
<object property="converterParameter" />  
```  
  
<a name="xamlValues_ConverterParameter"></a>   
## XAML Values  
 *converterParameter*  
 A value of the type expected by the converter, which might be an object element or a string depending on the definition and XAML capabilities both of the property type being used and of the implementation of the converter. The converter takes in that type through the `parameter` parameter as defined by its <xref:System.Windows.Data.IValueConverter.Convert%2A> and <xref:System.Windows.Data.IValueConverter.ConvertBack%2A> implementations.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.IMultiValueConverter" />
      </Docs>
    </Member>
    <Member MemberName="Mode">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingMode Mode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.BindingMode Mode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.Mode" />
      <MemberSignature Language="VB.NET" Value="Public Property Mode As BindingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingMode Mode { System::Windows::Data::BindingMode get(); void set(System::Windows::Data::BindingMode value); };" />
      <MemberSignature Language="F#" Value="member this.Mode : System.Windows.Data.BindingMode with get, set" Usage="System.Windows.Data.MultiBinding.Mode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates the direction of the data flow of this binding.</summary>
        <value>One of the <see cref="T:System.Windows.Data.BindingMode" /> values. The default value is <see cref="F:System.Windows.Data.BindingMode.Default" />, which returns the default binding mode value of the target dependency property. However, the default value varies for each dependency property. In general, user-editable control properties, such as <see cref="P:System.Windows.Controls.TextBox.Text" />, default to two-way bindings, whereas most other properties default to one-way bindings.  
  
 A programmatic way to determine whether a dependency property binds one-way or two-way by default is to get the property metadata of the property using <see cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" /> and then check the Boolean value of the <see cref="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" /> property.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The values of the <xref:System.Windows.Data.MultiBinding.Mode%2A> and <xref:System.Windows.Data.MultiBinding.UpdateSourceTrigger%2A> properties determine the functionality of the <xref:System.Windows.Data.MultiBinding> and are used as the default values for all the bindings in the collection unless an individual binding overrides these properties. For example, if the <xref:System.Windows.Data.MultiBinding.Mode%2A> property on the <xref:System.Windows.Data.MultiBinding> object is set to <xref:System.Windows.Data.BindingMode.TwoWay>, then all the bindings in the collection are considered <xref:System.Windows.Data.BindingMode.TwoWay> unless you set a different <xref:System.Windows.Data.MultiBinding.Mode%2A> value on one of the bindings explicitly. For more information, see the <xref:System.Windows.Data.Binding.Mode%2A?displayProperty=nameWithType> and <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A?displayProperty=nameWithType> properties.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnSourceUpdated">
      <MemberSignature Language="C#" Value="public bool NotifyOnSourceUpdated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnSourceUpdated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.NotifyOnSourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnSourceUpdated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnSourceUpdated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnSourceUpdated : bool with get, set" Usage="System.Windows.Data.MultiBinding.NotifyOnSourceUpdated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to raise the <see cref="E:System.Windows.FrameworkElement.SourceUpdated" /> event when a value is transferred from the binding target to the binding source.</summary>
        <value>
          <see langword="true" /> if the <see cref="E:System.Windows.FrameworkElement.SourceUpdated" /> event will be raised when the binding source value is updated; otherwise, <see langword="false" />. The default value is <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Data.Binding.NotifyOnSourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="NotifyOnTargetUpdated">
      <MemberSignature Language="C#" Value="public bool NotifyOnTargetUpdated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnTargetUpdated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.NotifyOnTargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnTargetUpdated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnTargetUpdated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnTargetUpdated : bool with get, set" Usage="System.Windows.Data.MultiBinding.NotifyOnTargetUpdated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to raise the <see cref="E:System.Windows.FrameworkElement.TargetUpdated" /> event when a value is transferred from the binding source to the binding target.</summary>
        <value>
          <see langword="true" /> if the <see cref="E:System.Windows.FrameworkElement.TargetUpdated" /> event will be raised when the binding target value is updated; otherwise, <see langword="false" />. The default value is <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Data.Binding.NotifyOnTargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="NotifyOnValidationError">
      <MemberSignature Language="C#" Value="public bool NotifyOnValidationError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.NotifyOnValidationError" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnValidationError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnValidationError : bool with get, set" Usage="System.Windows.Data.MultiBinding.NotifyOnValidationError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to raise the <see cref="E:System.Windows.Controls.Validation.Error" /> attached event on the bound element.</summary>
        <value>
          <see langword="true" /> if the <see cref="E:System.Windows.Controls.Validation.Error" /> attached event will be raised on the bound element when there is a validation error during source updates; otherwise, <see langword="false" />. The default value is <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Data.Binding.NotifyOnValidationError" />
        <altmember cref="P:System.Windows.Data.MultiBinding.ValidationRules" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.MultiBinding.ShouldSerializeBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeBindings : unit -&gt; bool" Usage="multiBinding.ShouldSerializeBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates whether the <see cref="P:System.Windows.Data.MultiBinding.Bindings" /> property should be persisted.</summary>
        <returns>
          <see langword="true" /> if the property value has changed from its default; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This `ShouldSerialize` method is provided because the <xref:System.Windows.Data.MultiBinding.Bindings%2A> property does not have a simple default value. This method indicates whether the property has changed from its default value. You typically invoke this method if you are either developing a designer for the <xref:System.Windows.Data.MultiBinding> or developing your own control incorporating the <xref:System.Windows.Data.MultiBinding>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeValidationRules">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeValidationRules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeValidationRules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.MultiBinding.ShouldSerializeValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeValidationRules () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeValidationRules();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeValidationRules : unit -&gt; bool" Usage="multiBinding.ShouldSerializeValidationRules " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates whether the <see cref="P:System.Windows.Data.MultiBinding.ValidationRules" /> property should be persisted.</summary>
        <returns>
          <see langword="true" /> if the property value has changed from its default; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This `ShouldSerialize` method is provided because the <xref:System.Windows.Data.MultiBinding.ValidationRules%2A> property does not have a simple default value. This method indicates whether the property has changed from its default value. You typically invoke this method if you are either developing a designer for the <xref:System.Windows.Data.MultiBinding> or developing your own control incorporating the <xref:System.Windows.Data.MultiBinding>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.MultiBinding.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The child object to add.</param>
        <summary>Adds a child object.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.MultiBinding.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">The text to add to the object.</param>
        <summary>Adds the text content of a node to the object.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSourceExceptionFilter">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceExceptionFilterCallback UpdateSourceExceptionFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.UpdateSourceExceptionFilterCallback UpdateSourceExceptionFilter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.UpdateSourceExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateSourceExceptionFilter As UpdateSourceExceptionFilterCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceExceptionFilterCallback ^ UpdateSourceExceptionFilter { System::Windows::Data::UpdateSourceExceptionFilterCallback ^ get(); void set(System::Windows::Data::UpdateSourceExceptionFilterCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateSourceExceptionFilter : System.Windows.Data.UpdateSourceExceptionFilterCallback with get, set" Usage="System.Windows.Data.MultiBinding.UpdateSourceExceptionFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceExceptionFilterCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a handler you can use to provide custom logic for handling exceptions that the binding engine encounters during the update of the binding source value. This is only applicable if you have associated the <see cref="T:System.Windows.Controls.ExceptionValidationRule" /> with your <see cref="T:System.Windows.Data.MultiBinding" /> object.</summary>
        <value>A method that provides custom logic for handling exceptions that the binding engine encounters during the update of the binding source value.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Windows.Controls.ExceptionValidationRule> class represents a built-in validation rule that checks for exceptions that are thrown during the update of the binding source properties. If you have associated the <xref:System.Windows.Controls.ExceptionValidationRule> object with your <xref:System.Windows.Data.MultiBinding> object, you can use this property to set a handler to provide custom logic for handling these exceptions.  
  
 For an example, see <xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A?displayProperty=nameWithType>.  
  
 For more information about the validation process for <xref:System.Windows.Data.MultiBinding> objects, see the <xref:System.Windows.Data.MultiBinding.ValidationRules%2A> property.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger UpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger UpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.UpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger UpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.Data.MultiBinding.UpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that determines the timing of binding source updates.</summary>
        <value>One of the <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> values. The default value is <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />, which returns the default <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> value of the target dependency property. However, the default value for most dependency properties is <see cref="F:System.Windows.Data.UpdateSourceTrigger.PropertyChanged" />, while the <see cref="P:System.Windows.Controls.TextBox.Text" /> property has a default value of <see cref="F:System.Windows.Data.UpdateSourceTrigger.LostFocus" />.  
  
 A programmatic way to determine the default <see cref="P:System.Windows.Data.Binding.UpdateSourceTrigger" /> value of a dependency property is to get the property metadata of the property using <see cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" /> and then check the value of the <see cref="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" /> property.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The values of the <xref:System.Windows.Data.MultiBinding.Mode%2A> and <xref:System.Windows.Data.MultiBinding.UpdateSourceTrigger%2A> properties determine the functionality of the <xref:System.Windows.Data.MultiBinding> and are used as the default values for all the bindings in the collection unless an individual binding overrides these properties. For example, if the <xref:System.Windows.Data.MultiBinding.Mode%2A> property on the <xref:System.Windows.Data.MultiBinding> object is set to <xref:System.Windows.Data.BindingMode.TwoWay>, then all the bindings in the collection are considered <xref:System.Windows.Data.BindingMode.TwoWay> unless you set a different <xref:System.Windows.Data.MultiBinding.Mode%2A> value on one of the bindings explicitly. For more information, see the <xref:System.Windows.Data.Binding.Mode%2A?displayProperty=nameWithType> and <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A?displayProperty=nameWithType> properties.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnDataErrors">
      <MemberSignature Language="C#" Value="public bool ValidatesOnDataErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnDataErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.ValidatesOnDataErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnDataErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnDataErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnDataErrors : bool with get, set" Usage="System.Windows.Data.MultiBinding.ValidatesOnDataErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to include the <see cref="T:System.Windows.Controls.DataErrorValidationRule" />.</summary>
        <value>
          <see langword="true" /> to include the <see cref="T:System.Windows.Controls.DataErrorValidationRule" />; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Setting this property provides an alternative to using the <xref:System.Windows.Controls.DataErrorValidationRule> element explicitly. The <xref:System.Windows.Controls.DataErrorValidationRule> is a built-in validation rule that checks for errors that are raised by the <xref:System.ComponentModel.IDataErrorInfo> implementation of the source object. If an error is raised, the binding engine creates a <xref:System.Windows.Controls.ValidationError> with the error and adds it to the <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> collection of the bound element. The lack of an error clears this validation feedback, unless another rule raises a validation issue.  
  
 For more information about the validation process for <xref:System.Windows.Data.MultiBinding> objects, see the <xref:System.Windows.Data.MultiBinding.ValidationRules%2A> property.  
  
 <xref:System.Windows.Data.MultiBinding.ValidatesOnDataErrors%2A> is introduced in the .NET Framework version 3.5.  For more information, see [Versions and Dependencies](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.MultiBinding.ValidatesOnExceptions" />
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnExceptions">
      <MemberSignature Language="C#" Value="public bool ValidatesOnExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.ValidatesOnExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnExceptions : bool with get, set" Usage="System.Windows.Data.MultiBinding.ValidatesOnExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to include the <see cref="T:System.Windows.Controls.ExceptionValidationRule" />.</summary>
        <value>
          <see langword="true" /> to include the <see cref="T:System.Windows.Controls.ExceptionValidationRule" />; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Setting this property provides an alternative to using the <xref:System.Windows.Controls.ExceptionValidationRule> element explicitly. The <xref:System.Windows.Controls.ExceptionValidationRule> is a built-in validation rule that checks for exceptions that are thrown during the update of the source property. If an exception is thrown, the binding engine creates a <xref:System.Windows.Controls.ValidationError> with the exception and adds it to the <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> collection of the bound element. The lack of an error clears this validation feedback, unless another rule raises a validation issue.  
  
 For more information about the validation process for <xref:System.Windows.Data.MultiBinding> objects, see the <xref:System.Windows.Data.MultiBinding.ValidationRules%2A> property.  
  
 <xref:System.Windows.Data.MultiBinding.ValidatesOnExceptions%2A> is introduced in the .NET Framework version 3.5.  For more information, see [Versions and Dependencies](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.MultiBinding.ValidatesOnDataErrors" />
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnNotifyDataErrors">
      <MemberSignature Language="C#" Value="public bool ValidatesOnNotifyDataErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnNotifyDataErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.ValidatesOnNotifyDataErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnNotifyDataErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnNotifyDataErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnNotifyDataErrors : bool with get, set" Usage="System.Windows.Data.MultiBinding.ValidatesOnNotifyDataErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to include the <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />.</summary>
        <value>
          <see langword="true" /> to include the <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />; otherwise, <see langword="false" />. The default is <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When <xref:System.Windows.Data.MultiBinding.ValidatesOnNotifyDataErrors%2A> is `true`, the binding checks for and reports errors that are raised by a data source that implements <xref:System.ComponentModel.INotifyDataErrorInfo>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationRules">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt; ValidationRules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Controls.ValidationRule&gt; ValidationRules" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.MultiBinding.ValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationRules As Collection(Of ValidationRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ ValidationRules { System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidationRules : System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;" Usage="System.Windows.Data.MultiBinding.ValidationRules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of <see cref="T:System.Windows.Controls.ValidationRule" /> objects for this instance of <see cref="T:System.Windows.Data.MultiBinding" />.</summary>
        <value>The collection of <see cref="T:System.Windows.Controls.ValidationRule" /> objects for this instance of <see cref="T:System.Windows.Data.MultiBinding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You can set validation rules on both the <xref:System.Windows.Data.MultiBinding> object and the individual <xref:System.Windows.Data.Binding> objects in the <xref:System.Windows.Data.MultiBinding> object. The binding engine evaluates the <xref:System.Windows.Data.MultiBinding.ValidationRules%2A> on the <xref:System.Windows.Data.MultiBinding> object when a value moves from the binding target property to the <xref:System.Windows.Data.IMultiValueConverter> object. After that, when a value moves from the converter to the binding source property of an individual binding, the binding engine evaluates the <xref:System.Windows.Data.Binding.ValidationRules%2A> on that <xref:System.Windows.Data.Binding> object.  
  
 For more information about the validation process and how to provide visual feedback upon invalidation, see "Data Validation" in [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!NOTE]
>  This property can be set in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] only by using the syntax shown, or by accessing the collection object and using its various methods, such as `Add`. The property used to access the collection object is read-only, whereas the collection itself is read-write.  
  
<a name="xamlPropertyElementUsage_ValidationRules"></a>   
## XAML Property Element Usage  
  
```  
<object>  
  <object.ValidationRules>  
    oneOrMoreValidationRules  
  </object.ValidationRules>  
</object>  
```  
  
<a name="xamlValues_ValidationRules"></a>   
## XAML Values  
 *oneOrMoreValidationRules*  
 One or more <xref:System.Windows.Controls.ValidationRule> objects. You can use the <xref:System.Windows.Controls.ExceptionValidationRule> class or create your custom rules by subclassing the <xref:System.Windows.Controls.ValidationRule> class.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159972">Binding Validation Sample</related>
      </Docs>
    </Member>
  </Members>
</Type>