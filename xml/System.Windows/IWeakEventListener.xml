<Type Name="IWeakEventListener" FullName="System.Windows.IWeakEventListener">
  <TypeSignature Language="C#" Value="public interface IWeakEventListener" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IWeakEventListener" />
  <TypeSignature Language="DocId" Value="T:System.Windows.IWeakEventListener" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Provides event listening support for classes that expect to receive events through the WeakEvent pattern and a <see cref="T:System.Windows.WeakEventManager" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Windows.WeakEventManager> (a dispatcher) forwards an event by calling the <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> method on classes that implement this interface, and that have been added as listeners by calling <xref:System.Windows.WeakEventManager> methods beforehand.  
  
 The principal reason for following the WeakEvent pattern is when the event source has an object lifetime that is potentially independent of the event listeners. Using the central event dispatching of a <xref:System.Windows.WeakEventManager> enables the handlers for listeners to be garbage collected (or manually purged) even if the source object lifetime extends beyond the listeners. By contrast, a normal event hookup using `+=` or equivalent language-specific event syntax causes the potentially still-connected source to hold a strong reference to the handlers. This keeps the listener references from being garbage collected in a timely fashion.  
  
 One common situation where the relationships between sources and listeners suggests the use of this pattern is the handling of update events coming from sources for data bindings.  
  
 You can use the WeakEvent pattern to listen for events that are external to your application. You only need to define a <xref:System.Windows.WeakEventManager> for it, provide listening behavior in <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A>, and use the <xref:System.Windows.WeakEventManager> to attach the handler references rather than `+=`.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ReceiveWeakEvent">
      <MemberSignature Language="C#" Value="public bool ReceiveWeakEvent (Type managerType, object sender, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReceiveWeakEvent(class System.Type managerType, object sender, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.IWeakEventListener.ReceiveWeakEvent(System.Type,System.Object,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="managerType">The type of the <see cref="T:System.Windows.WeakEventManager" /> calling this method.</param>
        <param name="sender">Object that originated the event.</param>
        <param name="e">Event data.</param>
        <summary>Receives events from the centralized event manager.</summary>
        <returns>
          <see langword="true" /> if the listener handled the event. It is considered an error by the <see cref="T:System.Windows.WeakEventManager" /> handling in [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] to register a listener for an event that the listener does not handle. Regardless, the method should return <see langword="false" /> if it receives an event that it does not recognize or handle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example implements ReceiveWeakEvent to provide WeakEvent pattern support for two hypothetical events `ClockwiseSpin` and `CounterclockwiseSpin` that each have a dedicated <xref:System.Windows.WeakEventManager> (not shown). This implementation calls class handler stubs for each supported event, casting the event data (in this case the two events share an event data type `SpinEventArgs`). The implementation returns `false` if the event received is not one that is expected.  
  
 [!code-cs[CorePseudocode#IWeakEventListener](~/add/codesnippet/csharp/CorePseudocode/corepseudocode.cs#iweakeventlistener)]
 [!code-vb[CorePseudocode#IWeakEventListener](~/add/codesnippet/visualbasic/corepseudocode/corepseudocode.vb#iweakeventlistener)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>